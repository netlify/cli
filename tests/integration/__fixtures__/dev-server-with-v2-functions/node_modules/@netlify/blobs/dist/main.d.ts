import http from 'node:http';

type Metadata = Record<string, unknown>;

type BlobInput = ReadableStream | string | ArrayBuffer | Blob;
type Fetcher = typeof globalThis.fetch;
declare enum HTTPMethod {
    DELETE = "delete",
    GET = "get",
    PUT = "put"
}

interface MakeStoreRequestOptions {
    body?: BlobInput | null;
    headers?: Record<string, string>;
    key?: string;
    metadata?: Metadata;
    method: HTTPMethod;
    parameters?: Record<string, string>;
    storeName: string;
}
interface ClientOptions {
    apiURL?: string;
    edgeURL?: string;
    fetch?: Fetcher;
    siteID: string;
    token: string;
}
declare class Client {
    private apiURL?;
    private edgeURL?;
    private fetch;
    private siteID;
    private token;
    constructor({ apiURL, edgeURL, fetch, siteID, token }: ClientOptions);
    private getFinalRequest;
    makeRequest({ body, headers: extraHeaders, key, metadata, method, parameters, storeName, }: MakeStoreRequestOptions): Promise<Response>;
}

interface BaseStoreOptions {
    client: Client;
}
interface DeployStoreOptions extends BaseStoreOptions {
    deployID: string;
}
interface NamedStoreOptions extends BaseStoreOptions {
    name: string;
}
type StoreOptions = DeployStoreOptions | NamedStoreOptions;
interface GetWithMetadataOptions {
    etag?: string;
}
interface GetWithMetadataResult {
    etag?: string;
    fresh: boolean;
    metadata: Metadata;
}
interface ListResult {
    blobs: ListResultBlob[];
}
interface ListResultWithDirectories extends ListResult {
    directories: string[];
}
interface ListResultBlob {
    etag: string;
    key: string;
}
interface ListOptions {
    cursor?: string;
    directories?: boolean;
    paginate?: boolean;
    prefix?: string;
}
interface SetOptions {
    /**
     * Arbitrary metadata object to associate with an entry. Must be seralizable
     * to JSON.
     */
    metadata?: Metadata;
}
declare class Store {
    private client;
    private name;
    constructor(options: StoreOptions);
    delete(key: string): Promise<void>;
    get(key: string): Promise<string>;
    get(key: string, { type }: {
        type: 'arrayBuffer';
    }): Promise<ArrayBuffer>;
    get(key: string, { type }: {
        type: 'blob';
    }): Promise<Blob>;
    get(key: string, { type }: {
        type: 'json';
    }): Promise<any>;
    get(key: string, { type }: {
        type: 'stream';
    }): Promise<ReadableStream>;
    get(key: string, { type }: {
        type: 'text';
    }): Promise<string>;
    getWithMetadata(key: string, options?: GetWithMetadataOptions): Promise<{
        data: string;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'arrayBuffer';
    } & GetWithMetadataOptions): Promise<{
        data: ArrayBuffer;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'blob';
    } & GetWithMetadataOptions): Promise<{
        data: Blob;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'json';
    } & GetWithMetadataOptions): Promise<{
        data: any;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'stream';
    } & GetWithMetadataOptions): Promise<{
        data: ReadableStream;
    } & GetWithMetadataResult>;
    getWithMetadata(key: string, options: {
        type: 'text';
    } & GetWithMetadataOptions): Promise<{
        data: string;
    } & GetWithMetadataResult>;
    list(options: ListOptions & {
        directories: true;
    }): Promise<ListResultWithDirectories>;
    list(options?: ListOptions & {
        directories?: false;
    }): Promise<ListResult>;
    set(key: string, data: BlobInput, { metadata }?: SetOptions): Promise<void>;
    setJSON(key: string, data: unknown, { metadata }?: SetOptions): Promise<void>;
    private static formatListResultBlob;
    private static validateKey;
    private static validateDeployID;
    private static validateStoreName;
    private listAndPaginate;
}

interface GetDeployStoreOptions extends Partial<ClientOptions> {
    deployID?: string;
}
/**
 * Gets a reference to a deploy-scoped store.
 */
declare const getDeployStore: (options?: GetDeployStoreOptions) => Store;
interface GetStoreOptions extends Partial<ClientOptions> {
    deployID?: string;
    name?: string;
}
/**
 * Gets a reference to a store.
 *
 * @param input Either a string containing the store name or an options object
 */
declare const getStore: {
    (name: string): Store;
    (options: GetStoreOptions): Store;
};

type Logger = (...message: unknown[]) => void;

interface BlobsServerOptions {
    /**
     * Whether debug-level information should be logged, such as internal errors
     * or information about incoming requests.
     */
    debug?: boolean;
    /**
     * Base directory to read and write files from.
     */
    directory: string;
    /**
     * Function to log messages. Defaults to `console.log`.
     */
    logger?: Logger;
    /**
     * Port to run the server on. Defaults to a random port.
     */
    port?: number;
    /**
     * Static authentication token that should be present in all requests. If not
     * supplied, no authentication check is performed.
     */
    token?: string;
}
declare class BlobsServer {
    private address;
    private debug;
    private directory;
    private logger;
    private port;
    private server?;
    private token?;
    constructor({ debug, directory, logger, port, token }: BlobsServerOptions);
    logDebug(...message: unknown[]): void;
    delete(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    get(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    list(options: {
        dataPath: string;
        metadataPath: string;
        rootPath: string;
        req: http.IncomingMessage;
        res: http.ServerResponse;
        url: URL;
    }): Promise<void>;
    put(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>;
    /**
     * Parses the URL and returns the filesystem paths where entries and metadata
     * should be stored.
     */
    getLocalPaths(url?: URL): {
        dataPath?: undefined;
        key?: undefined;
        metadataPath?: undefined;
        rootPath?: undefined;
    } | {
        dataPath: string;
        key: string;
        metadataPath: string;
        rootPath: string;
    };
    handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void | Promise<void>;
    sendResponse(req: http.IncomingMessage, res: http.ServerResponse, status: number, body?: string): void;
    start(): Promise<{
        address: string;
        family: string;
        port: number;
    }>;
    stop(): Promise<void>;
    validateAccess(req: http.IncomingMessage): boolean;
    /**
     * Traverses a path and collects both blobs and directories into a `result`
     * object, taking into account the `directories` and `prefix` parameters.
     */
    private static walk;
}

export { BlobsServer, getDeployStore, getStore };
