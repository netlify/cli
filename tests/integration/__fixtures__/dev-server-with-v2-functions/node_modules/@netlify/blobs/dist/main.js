// src/environment.ts
import { Buffer } from "buffer";
import { env } from "process";
var NETLIFY_CONTEXT_VARIABLE = "NETLIFY_BLOBS_CONTEXT";
var getEnvironmentContext = () => {
  if (!env[NETLIFY_CONTEXT_VARIABLE]) {
    return {};
  }
  const data = Buffer.from(env[NETLIFY_CONTEXT_VARIABLE], "base64").toString();
  try {
    return JSON.parse(data);
  } catch {
  }
  return {};
};
var MissingBlobsEnvironmentError = class extends Error {
  constructor(requiredProperties) {
    super(
      `The environment has not been configured to use Netlify Blobs. To use it manually, supply the following properties when creating a store: ${requiredProperties.join(
        ", "
      )}`
    );
    this.name = "MissingBlobsEnvironmentError";
  }
};

// src/metadata.ts
import { Buffer as Buffer2 } from "buffer";
var BASE64_PREFIX = "b64;";
var METADATA_HEADER_INTERNAL = "x-amz-meta-user";
var METADATA_HEADER_EXTERNAL = "netlify-blobs-metadata";
var METADATA_MAX_SIZE = 2 * 1024;
var encodeMetadata = (metadata) => {
  if (!metadata) {
    return null;
  }
  const encodedObject = Buffer2.from(JSON.stringify(metadata)).toString("base64");
  const payload = `b64;${encodedObject}`;
  if (METADATA_HEADER_EXTERNAL.length + payload.length > METADATA_MAX_SIZE) {
    throw new Error("Metadata object exceeds the maximum size");
  }
  return payload;
};
var decodeMetadata = (header) => {
  if (!header || !header.startsWith(BASE64_PREFIX)) {
    return {};
  }
  const encodedData = header.slice(BASE64_PREFIX.length);
  const decodedData = Buffer2.from(encodedData, "base64").toString();
  const metadata = JSON.parse(decodedData);
  return metadata;
};

// src/retry.ts
var DEFAULT_RETRY_DELAY = 5e3;
var MIN_RETRY_DELAY = 1e3;
var MAX_RETRY = 5;
var RATE_LIMIT_HEADER = "X-RateLimit-Reset";
var fetchAndRetry = async (fetch, url, options, attemptsLeft = MAX_RETRY) => {
  try {
    const res = await fetch(url, options);
    if (attemptsLeft > 0 && (res.status === 429 || res.status >= 500)) {
      const delay = getDelay(res.headers.get(RATE_LIMIT_HEADER));
      await sleep(delay);
      return fetchAndRetry(fetch, url, options, attemptsLeft - 1);
    }
    return res;
  } catch (error) {
    if (attemptsLeft === 0) {
      throw error;
    }
    const delay = getDelay();
    await sleep(delay);
    return fetchAndRetry(fetch, url, options, attemptsLeft - 1);
  }
};
var getDelay = (rateLimitReset) => {
  if (!rateLimitReset) {
    return DEFAULT_RETRY_DELAY;
  }
  return Math.max(Number(rateLimitReset) * 1e3 - Date.now(), MIN_RETRY_DELAY);
};
var sleep = (ms) => new Promise((resolve2) => {
  setTimeout(resolve2, ms);
});

// src/client.ts
var Client = class {
  constructor({ apiURL, edgeURL, fetch, siteID, token }) {
    this.apiURL = apiURL;
    this.edgeURL = edgeURL;
    this.fetch = fetch ?? globalThis.fetch;
    this.siteID = siteID;
    this.token = token;
    if (!this.fetch) {
      throw new Error(
        "Netlify Blobs could not find a `fetch` client in the global scope. You can either update your runtime to a version that includes `fetch` (like Node.js 18.0.0 or above), or you can supply your own implementation using the `fetch` property."
      );
    }
  }
  async getFinalRequest({ key, metadata, method, parameters = {}, storeName }) {
    const encodedMetadata = encodeMetadata(metadata);
    if (this.edgeURL) {
      const headers = {
        authorization: `Bearer ${this.token}`
      };
      if (encodedMetadata) {
        headers[METADATA_HEADER_EXTERNAL] = encodedMetadata;
      }
      const path = key ? `/${this.siteID}/${storeName}/${key}` : `/${this.siteID}/${storeName}`;
      const url2 = new URL(path, this.edgeURL);
      for (const key2 in parameters) {
        url2.searchParams.set(key2, parameters[key2]);
      }
      return {
        headers,
        url: url2.toString()
      };
    }
    const apiHeaders = { authorization: `Bearer ${this.token}` };
    const url = new URL(`/api/v1/sites/${this.siteID}/blobs`, this.apiURL ?? "https://api.netlify.com");
    for (const key2 in parameters) {
      url.searchParams.set(key2, parameters[key2]);
    }
    url.searchParams.set("context", storeName);
    if (key === void 0) {
      return {
        headers: apiHeaders,
        url: url.toString()
      };
    }
    url.pathname += `/${key}`;
    if (encodedMetadata) {
      apiHeaders[METADATA_HEADER_EXTERNAL] = encodedMetadata;
    }
    const res = await this.fetch(url.toString(), { headers: apiHeaders, method });
    if (res.status !== 200) {
      throw new Error(`Netlify Blobs has generated an internal error: ${res.status} response`);
    }
    const { url: signedURL } = await res.json();
    const userHeaders = encodedMetadata ? { [METADATA_HEADER_INTERNAL]: encodedMetadata } : void 0;
    return {
      headers: userHeaders,
      url: signedURL
    };
  }
  async makeRequest({
    body,
    headers: extraHeaders,
    key,
    metadata,
    method,
    parameters,
    storeName
  }) {
    const { headers: baseHeaders = {}, url } = await this.getFinalRequest({
      key,
      metadata,
      method,
      parameters,
      storeName
    });
    const headers = {
      ...baseHeaders,
      ...extraHeaders
    };
    if (method === "put" /* PUT */) {
      headers["cache-control"] = "max-age=0, stale-while-revalidate=60";
    }
    const options = {
      body,
      headers,
      method
    };
    if (body instanceof ReadableStream) {
      options.duplex = "half";
    }
    return fetchAndRetry(this.fetch, url, options);
  }
};
var getClientOptions = (options, contextOverride) => {
  const context = contextOverride ?? getEnvironmentContext();
  const siteID = context.siteID ?? options.siteID;
  const token = context.token ?? options.token;
  if (!siteID || !token) {
    throw new MissingBlobsEnvironmentError(["siteID", "token"]);
  }
  const clientOptions = {
    apiURL: context.apiURL ?? options.apiURL,
    edgeURL: context.edgeURL ?? options.edgeURL,
    fetch: options.fetch,
    siteID,
    token
  };
  return clientOptions;
};

// src/store.ts
import { Buffer as Buffer3 } from "buffer";

// src/util.ts
var BlobsInternalError = class extends Error {
  constructor(statusCode) {
    super(`Netlify Blobs has generated an internal error: ${statusCode} response`);
    this.name = "BlobsInternalError";
  }
};
var isNodeError = (error) => error instanceof Error;

// src/store.ts
var Store = class _Store {
  constructor(options) {
    this.client = options.client;
    if ("deployID" in options) {
      _Store.validateDeployID(options.deployID);
      this.name = `deploy:${options.deployID}`;
    } else {
      _Store.validateStoreName(options.name);
      this.name = options.name;
    }
  }
  async delete(key) {
    const res = await this.client.makeRequest({ key, method: "delete" /* DELETE */, storeName: this.name });
    if (res.status !== 200 && res.status !== 404) {
      throw new BlobsInternalError(res.status);
    }
  }
  async get(key, options) {
    const { type } = options ?? {};
    const res = await this.client.makeRequest({ key, method: "get" /* GET */, storeName: this.name });
    if (res.status === 404) {
      return null;
    }
    if (res.status !== 200) {
      throw new BlobsInternalError(res.status);
    }
    if (type === void 0 || type === "text") {
      return res.text();
    }
    if (type === "arrayBuffer") {
      return res.arrayBuffer();
    }
    if (type === "blob") {
      return res.blob();
    }
    if (type === "json") {
      return res.json();
    }
    if (type === "stream") {
      return res.body;
    }
    throw new BlobsInternalError(res.status);
  }
  async getWithMetadata(key, options) {
    const { etag: requestETag, type } = options ?? {};
    const headers = requestETag ? { "if-none-match": requestETag } : void 0;
    const res = await this.client.makeRequest({ headers, key, method: "get" /* GET */, storeName: this.name });
    if (res.status === 404) {
      return null;
    }
    if (res.status !== 200 && res.status !== 304) {
      throw new BlobsInternalError(res.status);
    }
    const responseETag = res?.headers.get("etag") ?? void 0;
    let metadata = {};
    try {
      metadata = decodeMetadata(res?.headers.get(METADATA_HEADER_INTERNAL));
    } catch {
      throw new Error(
        "An internal error occurred while trying to retrieve the metadata for an entry. Please try updating to the latest version of the Netlify Blobs client."
      );
    }
    const result = {
      etag: responseETag,
      fresh: false,
      metadata
    };
    if (res.status === 304 && requestETag) {
      return { data: null, ...result, fresh: true };
    }
    if (type === void 0 || type === "text") {
      return { data: await res.text(), ...result };
    }
    if (type === "arrayBuffer") {
      return { data: await res.arrayBuffer(), ...result };
    }
    if (type === "blob") {
      return { data: await res.blob(), ...result };
    }
    if (type === "json") {
      return { data: await res.json(), ...result };
    }
    if (type === "stream") {
      return { data: res.body, ...result };
    }
    throw new Error(`Invalid 'type' property: ${type}. Expected: arrayBuffer, blob, json, stream, or text.`);
  }
  async list(options = {}) {
    const cursor = options.paginate === false ? options.cursor : void 0;
    const maxPages = options.paginate === false ? 1 : Number.POSITIVE_INFINITY;
    const res = await this.listAndPaginate({
      currentPage: 1,
      directories: options.directories,
      maxPages,
      nextCursor: cursor,
      prefix: options.prefix
    });
    const blobs = res.blobs?.map(_Store.formatListResultBlob).filter(Boolean);
    if (options?.directories) {
      return {
        blobs,
        directories: res.directories?.filter(Boolean)
      };
    }
    return {
      blobs
    };
  }
  async set(key, data, { metadata } = {}) {
    _Store.validateKey(key);
    const res = await this.client.makeRequest({
      body: data,
      key,
      metadata,
      method: "put" /* PUT */,
      storeName: this.name
    });
    if (res.status !== 200) {
      throw new BlobsInternalError(res.status);
    }
  }
  async setJSON(key, data, { metadata } = {}) {
    _Store.validateKey(key);
    const payload = JSON.stringify(data);
    const headers = {
      "content-type": "application/json"
    };
    const res = await this.client.makeRequest({
      body: payload,
      headers,
      key,
      metadata,
      method: "put" /* PUT */,
      storeName: this.name
    });
    if (res.status !== 200) {
      throw new BlobsInternalError(res.status);
    }
  }
  static formatListResultBlob(result) {
    if (!result.key) {
      return null;
    }
    return {
      etag: result.etag,
      key: result.key
    };
  }
  static validateKey(key) {
    if (key.startsWith("/") || key.startsWith("%2F")) {
      throw new Error("Blob key must not start with forward slash (/).");
    }
    if (Buffer3.byteLength(key, "utf8") > 600) {
      throw new Error(
        "Blob key must be a sequence of Unicode characters whose UTF-8 encoding is at most 600 bytes long."
      );
    }
  }
  static validateDeployID(deployID) {
    if (!/^\w{1,24}$/.test(deployID)) {
      throw new Error(`'${deployID}' is not a valid Netlify deploy ID.`);
    }
  }
  static validateStoreName(name) {
    if (name.startsWith("deploy:") || name.startsWith("deploy%3A1")) {
      throw new Error("Store name must not start with the `deploy:` reserved keyword.");
    }
    if (name.includes("/") || name.includes("%2F")) {
      throw new Error("Store name must not contain forward slashes (/).");
    }
    if (Buffer3.byteLength(name, "utf8") > 64) {
      throw new Error(
        "Store name must be a sequence of Unicode characters whose UTF-8 encoding is at most 64 bytes long."
      );
    }
  }
  async listAndPaginate(options) {
    const {
      accumulator = { blobs: [], directories: [] },
      currentPage,
      directories,
      maxPages,
      nextCursor,
      prefix
    } = options;
    if (currentPage > maxPages || currentPage > 1 && !nextCursor) {
      return accumulator;
    }
    const parameters = {};
    if (nextCursor) {
      parameters.cursor = nextCursor;
    }
    if (prefix) {
      parameters.prefix = prefix;
    }
    if (directories) {
      parameters.directories = "true";
    }
    const res = await this.client.makeRequest({
      method: "get" /* GET */,
      parameters,
      storeName: this.name
    });
    if (res.status !== 200) {
      throw new BlobsInternalError(res.status);
    }
    try {
      const current = await res.json();
      const newAccumulator = {
        ...current,
        blobs: [...accumulator.blobs || [], ...current.blobs || []],
        directories: [...accumulator.directories || [], ...current.directories || []]
      };
      return this.listAndPaginate({
        accumulator: newAccumulator,
        currentPage: currentPage + 1,
        directories,
        maxPages,
        nextCursor: current.next_cursor
      });
    } catch (error) {
      throw new Error(`'list()' has returned an internal error: ${error}`);
    }
  }
};

// src/store_factory.ts
var getDeployStore = (options = {}) => {
  const context = getEnvironmentContext();
  const deployID = options.deployID ?? context.deployID;
  if (!deployID) {
    throw new MissingBlobsEnvironmentError(["deployID"]);
  }
  const clientOptions = getClientOptions(options, context);
  const client = new Client(clientOptions);
  return new Store({ client, deployID });
};
var getStore = (input) => {
  if (typeof input === "string") {
    const clientOptions = getClientOptions({});
    const client = new Client(clientOptions);
    return new Store({ client, name: input });
  }
  if (typeof input?.name === "string") {
    const { name } = input;
    const clientOptions = getClientOptions(input);
    if (!name) {
      throw new MissingBlobsEnvironmentError(["name"]);
    }
    const client = new Client(clientOptions);
    return new Store({ client, name });
  }
  if (typeof input?.deployID === "string") {
    const clientOptions = getClientOptions(input);
    const { deployID } = input;
    if (!deployID) {
      throw new MissingBlobsEnvironmentError(["deployID"]);
    }
    const client = new Client(clientOptions);
    return new Store({ client, deployID });
  }
  throw new Error(
    "The `getStore` method requires the name of the store as a string or as the `name` property of an options object"
  );
};

// src/server.ts
import { createReadStream, createWriteStream, promises as fs } from "fs";
import http from "http";
import { tmpdir } from "os";
import { dirname, join, relative, resolve, sep } from "path";
var BlobsServer = class _BlobsServer {
  constructor({ debug, directory, logger, port, token }) {
    this.address = "";
    this.debug = debug === true;
    this.directory = directory;
    this.logger = logger ?? console.log;
    this.port = port || 0;
    this.token = token;
  }
  logDebug(...message) {
    if (!this.debug) {
      return;
    }
    this.logger("[Netlify Blobs server]", ...message);
  }
  async delete(req, res) {
    const url = new URL(req.url ?? "", this.address);
    const { dataPath, key } = this.getLocalPaths(url);
    if (!dataPath || !key) {
      return this.sendResponse(req, res, 400);
    }
    try {
      await fs.rm(dataPath, { recursive: true });
    } catch (error) {
      if (isNodeError(error) && error.code === "ENOENT") {
        return this.sendResponse(req, res, 404);
      }
      return this.sendResponse(req, res, 500);
    }
    return this.sendResponse(req, res, 200);
  }
  async get(req, res) {
    const url = new URL(req.url ?? "", this.address);
    const { dataPath, key, metadataPath, rootPath } = this.getLocalPaths(url);
    if (!dataPath || !metadataPath) {
      return this.sendResponse(req, res, 400);
    }
    if (!key) {
      return this.list({ dataPath, metadataPath, rootPath, req, res, url });
    }
    const headers = {};
    try {
      const rawData = await fs.readFile(metadataPath, "utf8");
      const metadata = JSON.parse(rawData);
      const encodedMetadata = encodeMetadata(metadata);
      if (encodedMetadata) {
        headers[METADATA_HEADER_INTERNAL] = encodedMetadata;
      }
    } catch (error) {
      this.logDebug("Could not read metadata file:", error);
    }
    for (const name in headers) {
      res.setHeader(name, headers[name]);
    }
    const stream = createReadStream(dataPath);
    stream.on("error", (error) => {
      if (error.code === "EISDIR" || error.code === "ENOENT") {
        return this.sendResponse(req, res, 404);
      }
      return this.sendResponse(req, res, 500);
    });
    stream.pipe(res);
  }
  async list(options) {
    const { dataPath, rootPath, req, res, url } = options;
    const directories = url.searchParams.get("directories") === "true";
    const prefix = url.searchParams.get("prefix") ?? "";
    const result = {
      blobs: [],
      directories: []
    };
    try {
      await _BlobsServer.walk({ directories, path: dataPath, prefix, rootPath, result });
    } catch (error) {
      this.logDebug("Could not perform list:", error);
      return this.sendResponse(req, res, 500);
    }
    res.setHeader("content-type", "application/json");
    return this.sendResponse(req, res, 200, JSON.stringify(result));
  }
  async put(req, res) {
    const url = new URL(req.url ?? "", this.address);
    const { dataPath, key, metadataPath } = this.getLocalPaths(url);
    if (!dataPath || !key || !metadataPath) {
      return this.sendResponse(req, res, 400);
    }
    const metadataHeader = req.headers[METADATA_HEADER_EXTERNAL];
    const metadata = decodeMetadata(Array.isArray(metadataHeader) ? metadataHeader[0] : metadataHeader ?? null);
    try {
      const tempDirectory = await fs.mkdtemp(join(tmpdir(), "netlify-blobs"));
      const relativeDataPath = relative(this.directory, dataPath);
      const tempDataPath = join(tempDirectory, relativeDataPath);
      await fs.mkdir(dirname(tempDataPath), { recursive: true });
      await new Promise((resolve2, reject) => {
        req.pipe(createWriteStream(tempDataPath));
        req.on("end", resolve2);
        req.on("error", reject);
      });
      await fs.mkdir(dirname(dataPath), { recursive: true });
      await fs.rename(tempDataPath, dataPath);
      await fs.rm(tempDirectory, { force: true, recursive: true });
      await fs.mkdir(dirname(metadataPath), { recursive: true });
      await fs.writeFile(metadataPath, JSON.stringify(metadata));
    } catch (error) {
      this.logDebug("Error when writing data:", error);
      return this.sendResponse(req, res, 500);
    }
    return this.sendResponse(req, res, 200);
  }
  /**
   * Parses the URL and returns the filesystem paths where entries and metadata
   * should be stored.
   */
  getLocalPaths(url) {
    if (!url) {
      return {};
    }
    const [, siteID, storeName, ...key] = url.pathname.split("/");
    if (!siteID || !storeName) {
      return {};
    }
    const rootPath = resolve(this.directory, "entries", siteID, storeName);
    const dataPath = resolve(rootPath, ...key);
    const metadataPath = resolve(this.directory, "metadata", siteID, storeName, ...key);
    return { dataPath, key: key.join("/"), metadataPath, rootPath };
  }
  handleRequest(req, res) {
    if (!this.validateAccess(req)) {
      return this.sendResponse(req, res, 403);
    }
    switch (req.method) {
      case "DELETE":
        return this.delete(req, res);
      case "GET":
        return this.get(req, res);
      case "PUT":
        return this.put(req, res);
      default:
        return this.sendResponse(req, res, 405);
    }
  }
  sendResponse(req, res, status, body) {
    this.logDebug(`${req.method} ${req.url}: ${status}`);
    res.writeHead(status);
    res.end(body);
  }
  async start() {
    await fs.mkdir(this.directory, { recursive: true });
    const server = http.createServer((req, res) => this.handleRequest(req, res));
    this.server = server;
    return new Promise((resolve2, reject) => {
      server.listen(this.port, () => {
        const address = server.address();
        if (!address || typeof address === "string") {
          return reject(new Error("Server cannot be started on a pipe or Unix socket"));
        }
        this.address = `http://localhost:${address.port}`;
        resolve2(address);
      });
    });
  }
  async stop() {
    if (!this.server) {
      return;
    }
    await new Promise((resolve2, reject) => {
      this.server?.close((error) => {
        if (error) {
          return reject(error);
        }
        resolve2(null);
      });
    });
  }
  validateAccess(req) {
    if (!this.token) {
      return true;
    }
    const { authorization = "" } = req.headers;
    const parts = authorization.split(" ");
    if (parts.length !== 2 || parts[0].toLowerCase() !== "bearer") {
      return false;
    }
    return parts[1] === this.token;
  }
  /**
   * Traverses a path and collects both blobs and directories into a `result`
   * object, taking into account the `directories` and `prefix` parameters.
   */
  static async walk(options) {
    const { directories, path, prefix, result, rootPath } = options;
    const entries = await fs.readdir(path);
    for (const entry of entries) {
      const entryPath = join(path, entry);
      const stat = await fs.stat(entryPath);
      let key = relative(rootPath, entryPath);
      if (sep !== "/") {
        key = key.split(sep).join("/");
      }
      const mask = key.slice(0, prefix.length);
      const isMatch = prefix.startsWith(mask);
      if (!isMatch) {
        continue;
      }
      if (!stat.isDirectory()) {
        const etag = Math.random().toString().slice(2);
        result.blobs?.push({
          etag,
          key,
          last_modified: stat.mtime.toISOString(),
          size: stat.size
        });
        continue;
      }
      if (directories && key.startsWith(prefix)) {
        result.directories?.push(key);
        continue;
      }
      await _BlobsServer.walk({ directories, path: entryPath, prefix, rootPath, result });
    }
  }
};
export {
  BlobsServer,
  getDeployStore,
  getStore
};
