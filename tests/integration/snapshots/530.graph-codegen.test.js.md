# Snapshot report for `tests/integration/530.graph-codegen.test.js`

The actual snapshot is saved in `530.graph-codegen.test.js.snap`.

Generated by [AVA](https://avajs.dev).

## netlify graph handler codegen [#custom-queryWithFragment-javascript-esm]:/ListServicesQuery.js

> Snapshot 1

    '"import NetlifyGraph from /"./netlifyGraph/"/n/nexport const handler = async (event) => {/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = event.headers[/"authorization/"]?.split(/" /")[1]/n/n  //// If you want to use the API with your own access token:/n  // accessToken = event.netlifyGraphToken/n      /n  const eventBodyJson = JSON.parse(event.body || /"{}/");/n/n  const nfToken = event.queryStringParameters?.nfToken;/n  const siteId = event.queryStringParameters?.siteId;/n  const logoStyle = event.queryStringParameters?.logoStyle;/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return {/n      statusCode: 422,/n      body: JSON.stringify({/n        error: \'You must supply parameters for: `nfToken`, `siteId`\'/n      }),/n    };/n  }/n/n  const { errors: ListServicesQueryErrors, data: ListServicesQueryData } =/n    await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (ListServicesQueryErrors) {/n    console.error(JSON.stringify(ListServicesQueryErrors, null, 2));/n  }/n/n  console.log(JSON.stringify(ListServicesQueryData, null, 2));/n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      success: true,/n      ListServicesQueryErrors: ListServicesQueryErrors,/n      ListServicesQueryData: ListServicesQueryData/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser (after saving/n * the code to `ListServicesQuery.js`) with these helpers:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/.netlify/functions/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`,/n    {/n      method: /"GET/"/n    });/n/n    const text = await resp.text();/n/n    return JSON.parse(text);/n}/n*//n"'

## netlify graph handler codegen [Next.js-queryWithFragment-javascript-esm]:/ListServicesQuery.js

> Snapshot 1

    '"/nimport NetlifyGraph from /"./netlifyGraph/";/n/nexport const handler = async (req, res) => {/n  // By default, all API calls use no authentication/n  let accessToken = null;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = req.headers[/"authorization/"]?.split(/" /")[1];/n/n  //// If you want to use the API with your own access token:/n  // accessToken = process.env.NETLIFY_GRAPH_TOKEN;/n      /n  const eventBodyJson = req.body || {};/n/n  const nfToken = typeof req.query?.nfToken === \'string\' ? req.query?.nfToken : req.query?.nfToken[0];/n  const siteId = typeof req.query?.siteId === \'string\' ? req.query?.siteId : req.query?.siteId[0];/n  const logoStyle = typeof req.query?.logoStyle === \'string\' ? req.query?.logoStyle : req.query?.logoStyle[0];/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return res.status(422).json({/n        errors: [/"You must supply parameters for: `nfToken`, `siteId`/"],/n    });/n  }/n/n  const { errors, data } = await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken}); /n/n  if (errors) {/n    console.error(JSON.stringify(errors, null, 2));/n  }/n/n  console.log(JSON.stringify(data, null, 2));/n/n  res.setHeader(/"Content-Type/", /"application/json/");/n/n  return res.status(200).json({/n    errors, data/n  });/n};/n/nexport default handler;/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser with this helper:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/api/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`, {/n    method: /"GET/"/n  });/n/n  const text = await resp.text();/n/n  return JSON.parse(text);/n}/n*/"'

## netlify graph handler codegen [Next.js-queryWithFragment-javascript-esm]:/pages/ListServicesQueryForm.jsx

> Snapshot 1

    '"import Head from /"next/head/";/nimport React, { useState } from /"react/";/nimport { Auth } from \'netlify-graph-auth\';/n/nconst { NetlifyGraphAuth } = Auth;/n/nexport default function Form(props) {/n  const isServer = typeof window === /"undefined/";/n  const [formVariables, setFormVariables] = React.useState({});/n  const [result, setResult] = useState(null);/n  const [auth, setAuth] = useState(/n    isServer/n      ? null/n      : new NetlifyGraphAuth({/n          siteId: props.siteId,/n        })/n  );/n/n  const submitForm = async () => {/n    const res = await fetch(/"/api/ListServicesQuery/", {/n      body: JSON.stringify(formVariables),/n      headers: {/n        /"Content-Type/": /"application/json/",/n        ...auth?.authHeaders()/n      },/n      method: /"POST/"/n    });/n/n    const formResult = await res.json();/n    setResult(formResult);/n  };/n/n  const needsLoginService = auth?.findMissingAuthServices(result)[0];/n/n  return (/n    <div className=/"container/">/n      <Head>/n        <title>ListServicesQuery form</title>/n      </Head>/n      <main>/n        <h1>{props.title}</h1>/n        <form onSubmit={event => { event.preventDefault(); submitForm() }}>/n            <label htmlFor=/"nfToken/">nfToken</label><input id=/"nfToken/" type=/"text/" onChange={updateFormVariables(setFormVariables, [/"nfToken/"], (value) => value)} />/n          <label htmlFor=/"siteId/">siteId</label><input id=/"siteId/" type=/"text/" onChange={updateFormVariables(setFormVariables, [/"siteId/"], (value) => value)} />/n          <label htmlFor=/"logoStyle/">logoStyle</label><select id=/"logoStyle/" onChange={updateFormVariables(setFormVariables, [/"logoStyle/"], (value) => value)}> <option value=/"DEFAULT/">DEFAULT</option> <option value=/"ROUNDED_RECTANGLE/">ROUNDED_RECTANGLE</option> </select>/n            <input type=/"submit/" />/n          </form>/n        {needsLoginService ? (/n          <button/n          onClick={async () => {/n            await auth.login(needsLoginService);/n            const loginSuccess = await auth.isLoggedIn(needsLoginService);/n            if (loginSuccess) {/n              console.log(/"Successfully logged into /" + needsLoginService);/n              submitForm();/n            } else {/n              console.log(/"The user did not grant auth to /" + needsLoginService);/n            }/n          }}/n        >/n          {`Log in to ${needsLoginService.graphQLField}`}/n        </button>) /n        : null}/n        <pre>{JSON.stringify(formVariables, null, 2)}</pre>/n        <pre>{JSON.stringify(result, null, 2)}</pre>/n      </main>/n    </div>/n  )/n}/n/nexport async function getServerSideProps(context) {/n  const siteId = process.env.SITE_ID;/n  if (!siteId) {/n    throw new Error(/"SITE_ID environment variable is not set. Be sure to run `netlify link` before `netlify dev`/");/n  }/n/n  return {/n    props: {/n      title: /"ListServicesQuery form/",/n      siteId: siteId/n    }/n  }/n}/n/nconst updateFormVariables = (setFormVariables, path, coerce) => {/n  const setIn = (object, path, value) => {/n    if (path.length === 1) {/n      if (value === null) {/n        delete object[path[0]];/n      } else {/n        object[path[0]] = value;/n      }/n    } else {/n      if ([undefined, null].indexOf(object[path[0]]) > -1) {/n        object[path[0]] = typeof path[1] === /"number/" ?  [] : {};/n      }/n      setIn(object[path[0]], path.slice(1), value);/n    }/n    return object;/n  };/n/n  const formInputHandler = (event) => {/n    // We parse the form input, coerce it to the correct type, and then update the form variables/n    const rawValue = event.target.value;/n    // We take a blank input to mean `null`/n    const value = rawValue === /"/" ? null : rawValue;/n    setFormVariables((oldFormVariables) => {/n      const newValue = setIn(oldFormVariables, path, coerce(value));/n      return { ...newValue };/n    });/n  };/n/n  return formInputHandler;/n};/n"'

## netlify graph handler codegen [Remix-queryWithFragment-javascript-esm]:/app/routes/ListServicesQuery.js

> Snapshot 1

    '"import { json, Form, useActionData, useTransition } from /"remix/";/nimport NetlifyGraph from /".,netlifyGraph/";/n/nexport const action = async ({ context, request }) => {/n  const formData = await request.formData();/n/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the API with your own access token:/n  // accessToken = context.netlifyGraphToken;/n/n  const nfTokenFormValue = formData.get(/"nfToken/");/nconst nfToken = nfTokenFormValue;/n/n  const siteIdFormValue = formData.get(/"siteId/");/nconst siteId = siteIdFormValue;/n/n  const logoStyleFormValue = formData.get(/"logoStyle/");/nconst logoStyle = logoStyleFormValue;/n/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return json(/n      {/n        errors: [/"You must supply parameters for: `nfToken`, `siteId`/"],/n      },/n      { status: 422 }/n    );/n  }/n/n  const { errors, data } = await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (errors) {/n    console.error(JSON.stringify(errors, null, 2));/n  }/n/n  console.log(JSON.stringify(data, null, 2));/n/n  return json({ data, errors });/n};/n/nexport default function handler() {/n  const results = useActionData();/n  const transition = useTransition();/n/n  const errors = results?.errors;/n  const data = results?.data;/n/n/n  return (/n    <Form method=/"post/">/n       <p><label htmlFor=/"nfToken/">nfToken</label><input id=/"nfToken/" name=/"nfToken/" type=/"text/" /></p>/n  <p><label htmlFor=/"siteId/">siteId</label><input id=/"siteId/" name=/"siteId/" type=/"text/" /></p>/n  <p><label htmlFor=/"logoStyle/">logoStyle</label><select id=/"logoStyle/" name=/"logoStyle/"> <option value=/"DEFAULT/">DEFAULT</option> <option value=/"ROUNDED_RECTANGLE/">ROUNDED_RECTANGLE</option> </select></p>/n  <p>/n    <button type=/"submit/">/n      {transition.submission/n        ? /"Submitting.../"/n        : /"Run ListServicesQuery/"}/n    </button>/n  </p>/n/n     {errors ? (<pre className=/"error/">{JSON.stringify(errors, null, 2)}</pre>) : null}/n     {data ? (<pre>{JSON.stringify(data, null, 2)}</pre>) : null}/n    </Form>/n  );/n}/n"'

## netlify graph handler codegen [unknown-queryWithFragment-javascript-esm]:/ListServicesQuery.js

> Snapshot 1

    '"import NetlifyGraph from /"./netlifyGraph/"/n/nexport const handler = async (event) => {/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = event.headers[/"authorization/"]?.split(/" /")[1]/n/n  //// If you want to use the API with your own access token:/n  // accessToken = event.netlifyGraphToken/n      /n  const eventBodyJson = JSON.parse(event.body || /"{}/");/n/n  const nfToken = event.queryStringParameters?.nfToken;/n  const siteId = event.queryStringParameters?.siteId;/n  const logoStyle = event.queryStringParameters?.logoStyle;/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return {/n      statusCode: 422,/n      body: JSON.stringify({/n        error: \'You must supply parameters for: `nfToken`, `siteId`\'/n      }),/n    };/n  }/n/n  const { errors: ListServicesQueryErrors, data: ListServicesQueryData } =/n    await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (ListServicesQueryErrors) {/n    console.error(JSON.stringify(ListServicesQueryErrors, null, 2));/n  }/n/n  console.log(JSON.stringify(ListServicesQueryData, null, 2));/n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      success: true,/n      ListServicesQueryErrors: ListServicesQueryErrors,/n      ListServicesQueryData: ListServicesQueryData/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser (after saving/n * the code to `ListServicesQuery.js`) with these helpers:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/.netlify/functions/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`,/n    {/n      method: /"GET/"/n    });/n/n    const text = await resp.text();/n/n    return JSON.parse(text);/n}/n*//n"'

## netlify graph handler codegen [#custom-queryWithFragment-typescript-esm]:/ListServicesQuery.ts

> Snapshot 1

    '"import NetlifyGraph from /"./netlifyGraph/"/n/nexport const handler = async (event) => {/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = event.headers[/"authorization/"]?.split(/" /")[1]/n/n  //// If you want to use the API with your own access token:/n  // accessToken = event.netlifyGraphToken/n      /n  const eventBodyJson = JSON.parse(event.body || /"{}/");/n/n  const nfToken = event.queryStringParameters?.nfToken;/n  const siteId = event.queryStringParameters?.siteId;/n  const logoStyle = event.queryStringParameters?.logoStyle;/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return {/n      statusCode: 422,/n      body: JSON.stringify({/n        error: \'You must supply parameters for: `nfToken`, `siteId`\'/n      }),/n    };/n  }/n/n  const { errors: ListServicesQueryErrors, data: ListServicesQueryData } =/n    await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (ListServicesQueryErrors) {/n    console.error(JSON.stringify(ListServicesQueryErrors, null, 2));/n  }/n/n  console.log(JSON.stringify(ListServicesQueryData, null, 2));/n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      success: true,/n      ListServicesQueryErrors: ListServicesQueryErrors,/n      ListServicesQueryData: ListServicesQueryData/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser (after saving/n * the code to `ListServicesQuery.js`) with these helpers:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/.netlify/functions/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`,/n    {/n      method: /"GET/"/n    });/n/n    const text = await resp.text();/n/n    return JSON.parse(text);/n}/n*//n"'

## netlify graph handler codegen [Next.js-queryWithFragment-typescript-esm]:/ListServicesQuery.ts

> Snapshot 1

    '"import type { NextApiRequest, NextApiResponse } from /"next/";/nimport NetlifyGraph from /"./netlifyGraph/";/n/nexport const handler = async (req: NextApiRequest, res: NextApiResponse) => {/n  // By default, all API calls use no authentication/n  let accessToken = null;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = req.headers[/"authorization/"]?.split(/" /")[1];/n/n  //// If you want to use the API with your own access token:/n  // accessToken = process.env.NETLIFY_GRAPH_TOKEN;/n      /n  const eventBodyJson = req.body || {};/n/n  const nfToken = typeof req.query?.nfToken === \'string\' ? req.query?.nfToken : req.query?.nfToken[0];/n  const siteId = typeof req.query?.siteId === \'string\' ? req.query?.siteId : req.query?.siteId[0];/n  const logoStyle = typeof req.query?.logoStyle === \'string\' ? req.query?.logoStyle : req.query?.logoStyle[0];/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return res.status(422).json({/n        errors: [/"You must supply parameters for: `nfToken`, `siteId`/"],/n    });/n  }/n/n  const { errors, data } = await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken}); /n/n  if (errors) {/n    console.error(JSON.stringify(errors, null, 2));/n  }/n/n  console.log(JSON.stringify(data, null, 2));/n/n  res.setHeader(/"Content-Type/", /"application/json/");/n/n  return res.status(200).json({/n    errors, data/n  });/n};/n/nexport default handler;/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser with this helper:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/api/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`, {/n    method: /"GET/"/n  });/n/n  const text = await resp.text();/n/n  return JSON.parse(text);/n}/n*/"'

## netlify graph handler codegen [Next.js-queryWithFragment-typescript-esm]:/pages/ListServicesQueryForm.tsx

> Snapshot 1

    '"import Head from /"next/head/";/nimport React, { useState } from /"react/";/nimport { Auth } from \'netlify-graph-auth\';/nimport NetlifyGraphAuth = Auth.NetlifyGraphAuth;/n/nexport default function Form(props) {/n  const isServer = typeof window === /"undefined/";/n  const [formVariables, setFormVariables] = React.useState({});/n  const [result, setResult] = useState(null);/n  const [auth, setAuth] = useState(/n    isServer/n      ? null/n      : new NetlifyGraphAuth({/n          siteId: props.siteId,/n        })/n  );/n/n  const submitForm = async () => {/n    const res = await fetch(/"/api/ListServicesQuery/", {/n      body: JSON.stringify(formVariables),/n      headers: {/n        /"Content-Type/": /"application/json/",/n        ...auth?.authHeaders()/n      },/n      method: /"POST/"/n    });/n/n    const formResult = await res.json();/n    setResult(formResult);/n  };/n/n  const needsLoginService = auth?.findMissingAuthServices(result)[0];/n/n  return (/n    <div className=/"container/">/n      <Head>/n        <title>ListServicesQuery form</title>/n      </Head>/n      <main>/n        <h1>{props.title}</h1>/n        <form onSubmit={event => { event.preventDefault(); submitForm() }}>/n            <label htmlFor=/"nfToken/">nfToken</label><input id=/"nfToken/" type=/"text/" onChange={updateFormVariables(setFormVariables, [/"nfToken/"], (value) => value)} />/n          <label htmlFor=/"siteId/">siteId</label><input id=/"siteId/" type=/"text/" onChange={updateFormVariables(setFormVariables, [/"siteId/"], (value) => value)} />/n          <label htmlFor=/"logoStyle/">logoStyle</label><select id=/"logoStyle/" onChange={updateFormVariables(setFormVariables, [/"logoStyle/"], (value) => value)}> <option value=/"DEFAULT/">DEFAULT</option> <option value=/"ROUNDED_RECTANGLE/">ROUNDED_RECTANGLE</option> </select>/n            <input type=/"submit/" />/n          </form>/n        {needsLoginService ? (/n          <button/n          onClick={async () => {/n            await auth.login(needsLoginService);/n            const loginSuccess = await auth.isLoggedIn(needsLoginService);/n            if (loginSuccess) {/n              console.log(/"Successfully logged into /" + needsLoginService);/n              submitForm();/n            } else {/n              console.log(/"The user did not grant auth to /" + needsLoginService);/n            }/n          }}/n        >/n          {`Log in to ${needsLoginService.graphQLField}`}/n        </button>) /n        : null}/n        <pre>{JSON.stringify(formVariables, null, 2)}</pre>/n        <pre>{JSON.stringify(result, null, 2)}</pre>/n      </main>/n    </div>/n  )/n}/n/nexport async function getServerSideProps(context) {/n  const siteId = process.env.SITE_ID;/n  if (!siteId) {/n    throw new Error(/"SITE_ID environment variable is not set. Be sure to run `netlify link` before `netlify dev`/");/n  }/n/n  return {/n    props: {/n      title: /"ListServicesQuery form/",/n      siteId: siteId/n    }/n  }/n}/n/nconst updateFormVariables = (setFormVariables, path, coerce) => {/n  const setIn = (object, path, value) => {/n    if (path.length === 1) {/n      if (value === null) {/n        delete object[path[0]];/n      } else {/n        object[path[0]] = value;/n      }/n    } else {/n      if ([undefined, null].indexOf(object[path[0]]) > -1) {/n        object[path[0]] = typeof path[1] === /"number/" ?  [] : {};/n      }/n      setIn(object[path[0]], path.slice(1), value);/n    }/n    return object;/n  };/n/n  const formInputHandler = (event) => {/n    // We parse the form input, coerce it to the correct type, and then update the form variables/n    const rawValue = event.target.value;/n    // We take a blank input to mean `null`/n    const value = rawValue === /"/" ? null : rawValue;/n    setFormVariables((oldFormVariables) => {/n      const newValue = setIn(oldFormVariables, path, coerce(value));/n      return { ...newValue };/n    });/n  };/n/n  return formInputHandler;/n};/n"'

## netlify graph handler codegen [Remix-queryWithFragment-typescript-esm]:/app/routes/ListServicesQuery.tsx

> Snapshot 1

    '"import { ActionFunction, json, Form, useActionData, useTransition } from /"remix/";/nimport NetlifyGraph from /".,netlifyGraph/";/nimport invariant from /"tiny-invariant/";/n/nexport const action: ActionFunction = async ({ context, request }) => {/n  const formData = await request.formData();/n/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the API with your own access token:/n  // accessToken = context.netlifyGraphToken;/n/n  const nfTokenFormValue = formData.get(/"nfToken/");/ninvariant(typeof nfTokenFormValue === /"string/");/nconst nfToken = nfTokenFormValue;/n/n  const siteIdFormValue = formData.get(/"siteId/");/ninvariant(typeof siteIdFormValue === /"string/");/nconst siteId = siteIdFormValue;/n/n  const logoStyleFormValue = formData.get(/"logoStyle/");/ninvariant(typeof logoStyleFormValue === /"string/");/nconst logoStyle = logoStyleFormValue;/n/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return json(/n      {/n        errors: [/"You must supply parameters for: `nfToken`, `siteId`/"],/n      },/n      { status: 422 }/n    );/n  }/n/n  const { errors, data } = await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (errors) {/n    console.error(JSON.stringify(errors, null, 2));/n  }/n/n  console.log(JSON.stringify(data, null, 2));/n/n  return json({ data, errors });/n};/n/nexport default function handler() {/n  const results = useActionData();/n  const transition = useTransition();/n/n  const errors = results?.errors;/n  const data: NetlifyGraph.ListServicesQuery[/"data/"] = results?.data;/n/n/n  return (/n    <Form method=/"post/">/n       <p><label htmlFor=/"nfToken/">nfToken</label><input id=/"nfToken/" name=/"nfToken/" type=/"text/" /></p>/n  <p><label htmlFor=/"siteId/">siteId</label><input id=/"siteId/" name=/"siteId/" type=/"text/" /></p>/n  <p><label htmlFor=/"logoStyle/">logoStyle</label><select id=/"logoStyle/" name=/"logoStyle/"> <option value=/"DEFAULT/">DEFAULT</option> <option value=/"ROUNDED_RECTANGLE/">ROUNDED_RECTANGLE</option> </select></p>/n  <p>/n    <button type=/"submit/">/n      {transition.submission/n        ? /"Submitting.../"/n        : /"Run ListServicesQuery/"}/n    </button>/n  </p>/n/n     {errors ? (<pre className=/"error/">{JSON.stringify(errors, null, 2)}</pre>) : null}/n     {data ? (<pre>{JSON.stringify(data, null, 2)}</pre>) : null}/n    </Form>/n  );/n}/n"'

## netlify graph handler codegen [unknown-queryWithFragment-typescript-esm]:/ListServicesQuery.ts

> Snapshot 1

    '"import NetlifyGraph from /"./netlifyGraph/"/n/nexport const handler = async (event) => {/n  // By default, all API calls use no authentication/n  let accessToken;/n/n  //// If you want to use the client\'s accessToken when making API calls on the user\'s behalf:/n  // accessToken = event.headers[/"authorization/"]?.split(/" /")[1]/n/n  //// If you want to use the API with your own access token:/n  // accessToken = event.netlifyGraphToken/n      /n  const eventBodyJson = JSON.parse(event.body || /"{}/");/n/n  const nfToken = event.queryStringParameters?.nfToken;/n  const siteId = event.queryStringParameters?.siteId;/n  const logoStyle = event.queryStringParameters?.logoStyle;/n/n  if (nfToken === undefined || nfToken === null || siteId === undefined || siteId === null) {/n    return {/n      statusCode: 422,/n      body: JSON.stringify({/n        error: \'You must supply parameters for: `nfToken`, `siteId`\'/n      }),/n    };/n  }/n/n  const { errors: ListServicesQueryErrors, data: ListServicesQueryData } =/n    await NetlifyGraph.fetchListServicesQuery({ nfToken: nfToken, siteId: siteId, logoStyle: logoStyle }, {accessToken: accessToken});/n/n  if (ListServicesQueryErrors) {/n    console.error(JSON.stringify(ListServicesQueryErrors, null, 2));/n  }/n/n  console.log(JSON.stringify(ListServicesQueryData, null, 2));/n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      success: true,/n      ListServicesQueryErrors: ListServicesQueryErrors,/n      ListServicesQueryData: ListServicesQueryData/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n/n/** /n * Client-side invocations:/n * Call your Netlify function from the browser (after saving/n * the code to `ListServicesQuery.js`) with these helpers:/n *//n/n/**/nasync function fetchListServicesQuery(params) {/n  const {nfToken, siteId, logoStyle} = params || {};/n  const resp = await fetch(`/.netlify/functions/ListServicesQuery?nfToken=${nfToken}&siteId=${siteId}&logoStyle=${logoStyle}`,/n    {/n      method: /"GET/"/n    });/n/n    const text = await resp.text();/n/n    return JSON.parse(text);/n}/n*//n"'

## netlify graph handler codegen [#custom-subscriptionWithFragment-javascript-esm]:/TestSubscription.js

> Snapshot 1

    '"import NetlifyGraph from /".,netlifyGraph/"/n/nexport const handler = async (event, context) => {/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent(event);/n/n  if (!payload) {/n    return {/n      statusCode: 412,/n      data: JSON.stringify({/n        success: false,/n        error: \'Unable to verify payload signature\',/n      }),/n    };/n  }/n  const { errors: TestSubscriptionErrors, data: TestSubscriptionData } = payload;/n/n  if (TestSubscriptionErrors) {/n    console.error(TestSubscriptionErrors);/n  }/n/n  console.log(TestSubscriptionData);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return {/n   *   statusCode: 410,/n   *   body: JSON.stringify(null),/n   *   headers: {/n   *     \'content-type\': \'application/json\',/n   *   },/n   * }/n   *//n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      successfullyProcessedIncomingWebhook: true,/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n"'

## netlify graph handler codegen [Next.js-subscriptionWithFragment-javascript-esm]:/TestSubscription.js

> Snapshot 1

    '"import NetlifyGraph from /"./netlifyGraph/";/n/nexport const handler = async (req, res) => {/n  const reqBody = await extractBody(req);/n/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent({/n    headers: {/n      /"x-netlify-graph-signature/": req.headers[/n        /"x-netlify-graph-signature/"/n      ]/n    },/n    body: reqBody,/n  });/n/n  if (!payload) {/n    return res.status(422).json({/n      success: false,/n      error: \'Unable to verify payload signature\',/n    });/n  }/n/n  const { errors, data } = payload;/n/n  if (errors) {/n    console.error(errors);/n  }/n/n  console.log(data);/n/n  res.setHeader(/"Content-Type/", /"application/json/");/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   * /n   * return res.status(410).json({});/n   *//n/n  return res.status(200).json({/n    successfullyProcessedIncomingWebhook: true,/n  });/n};/n/nexport default handler;/n/nexport const config = {/n  api: {/n    // We manually parse the body of the request in order to verify/n    // that it\'s signed by Netlify before processing the event./n    bodyParser: false,/n  },/n};/n/nconst extractBody = (req) => {/n  let body = [];/n  const promise = new Promise((resolve, reject) => {/n    req/n      .on(/"data/", (chunk) => {/n        body.push(chunk);/n      })/n      .on(/"end/", () => {/n        const fullBody = Buffer.concat(body).toString();/n        resolve(fullBody);/n      });/n  });/n/n  return promise;/n};/n"'

## netlify graph handler codegen [Remix-subscriptionWithFragment-javascript-esm]:/app/routes/webhooks/TestSubscription.js

> Snapshot 1

    '"import { json } from /"remix/";/nimport NetlifyGraph from /"../.,netlifyGraph/";/n/nexport const action = async ({ context, request }) => {/n  const reqBody = await request.text();/n/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent({/n    body: reqBody,/n    headers: {/n      \'x-netlify-graph-signature\': context.netlifyGraphSignature/n    },/n  });/n/n  if (!payload) {/n    return json({/n      success: false,/n      error: \'Unable to verify payload signature\',/n    }, { status: 422 });/n  }/n/n  const { errors, data } = payload;/n/n  if (errors) {/n    console.error(errors);/n  }/n/n  console.log(data);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return json({}, { status: 410 });/n   *//n/n  return json({/n    successfullyProcessedIncomingWebhook: true,/n  });/n};/n"'

## netlify graph handler codegen [unknown-subscriptionWithFragment-javascript-esm]:/TestSubscription.js

> Snapshot 1

    '"import NetlifyGraph from /".,netlifyGraph/"/n/nexport const handler = async (event, context) => {/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent(event);/n/n  if (!payload) {/n    return {/n      statusCode: 412,/n      data: JSON.stringify({/n        success: false,/n        error: \'Unable to verify payload signature\',/n      }),/n    };/n  }/n  const { errors: TestSubscriptionErrors, data: TestSubscriptionData } = payload;/n/n  if (TestSubscriptionErrors) {/n    console.error(TestSubscriptionErrors);/n  }/n/n  console.log(TestSubscriptionData);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return {/n   *   statusCode: 410,/n   *   body: JSON.stringify(null),/n   *   headers: {/n   *     \'content-type\': \'application/json\',/n   *   },/n   * }/n   *//n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      successfullyProcessedIncomingWebhook: true,/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n"'

## netlify graph handler codegen [#custom-subscriptionWithFragment-typescript-esm]:/TestSubscription.ts

> Snapshot 1

    '"import NetlifyGraph from /".,netlifyGraph/"/n/nexport const handler = async (event, context) => {/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent(event);/n/n  if (!payload) {/n    return {/n      statusCode: 412,/n      data: JSON.stringify({/n        success: false,/n        error: \'Unable to verify payload signature\',/n      }),/n    };/n  }/n  const { errors: TestSubscriptionErrors, data: TestSubscriptionData } = payload;/n/n  if (TestSubscriptionErrors) {/n    console.error(TestSubscriptionErrors);/n  }/n/n  console.log(TestSubscriptionData);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return {/n   *   statusCode: 410,/n   *   body: JSON.stringify(null),/n   *   headers: {/n   *     \'content-type\': \'application/json\',/n   *   },/n   * }/n   *//n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      successfullyProcessedIncomingWebhook: true,/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n"'

## netlify graph handler codegen [Next.js-subscriptionWithFragment-typescript-esm]:/TestSubscription.ts

> Snapshot 1

    '"import type { NextApiRequest, NextApiResponse } from /"next/";/nimport NetlifyGraph from /"./netlifyGraph/";/n/nexport const handler = async (req: NextApiRequest, res: NextApiResponse) => {/n  const reqBody = await extractBody(req);/n/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent({/n    headers: {/n      /"x-netlify-graph-signature/": req.headers[/n        /"x-netlify-graph-signature/"/n      ] as string/n    },/n    body: reqBody,/n  });/n/n  if (!payload) {/n    return res.status(422).json({/n      success: false,/n      error: \'Unable to verify payload signature\',/n    });/n  }/n/n  const { errors, data } = payload;/n/n  if (errors) {/n    console.error(errors);/n  }/n/n  console.log(data);/n/n  res.setHeader(/"Content-Type/", /"application/json/");/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   * /n   * return res.status(410).json({});/n   *//n/n  return res.status(200).json({/n    successfullyProcessedIncomingWebhook: true,/n  });/n};/n/nexport default handler;/n/nexport const config = {/n  api: {/n    // We manually parse the body of the request in order to verify/n    // that it\'s signed by Netlify before processing the event./n    bodyParser: false,/n  },/n};/n/nconst extractBody = (req: NextApiRequest): Promise<string> => {/n  let body = [];/n  const promise: Promise<string> = new Promise((resolve, reject) => {/n    req/n      .on(/"data/", (chunk) => {/n        body.push(chunk);/n      })/n      .on(/"end/", () => {/n        const fullBody = Buffer.concat(body).toString();/n        resolve(fullBody);/n      });/n  });/n/n  return promise;/n};/n"'

## netlify graph handler codegen [Remix-subscriptionWithFragment-typescript-esm]:/app/routes/webhooks/TestSubscription.tsx

> Snapshot 1

    '"import { ActionFunction, json } from /"remix/";/nimport NetlifyGraph from /"../.,netlifyGraph/";/n/nexport const action: ActionFunction = async ({ context, request }) => {/n  const reqBody = await request.text();/n/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent({/n    body: reqBody,/n    headers: {/n      \'x-netlify-graph-signature\': context.netlifyGraphSignature/n    },/n  });/n/n  if (!payload) {/n    return json({/n      success: false,/n      error: \'Unable to verify payload signature\',/n    }, { status: 422 });/n  }/n/n  const { errors, data } = payload;/n/n  if (errors) {/n    console.error(errors);/n  }/n/n  console.log(data);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return json({}, { status: 410 });/n   *//n/n  return json({/n    successfullyProcessedIncomingWebhook: true,/n  });/n};/n"'

## netlify graph handler codegen [unknown-subscriptionWithFragment-typescript-esm]:/TestSubscription.ts

> Snapshot 1

    '"import NetlifyGraph from /".,netlifyGraph/"/n/nexport const handler = async (event, context) => {/n  const payload = NetlifyGraph.parseAndVerifyTestSubscriptionEvent(event);/n/n  if (!payload) {/n    return {/n      statusCode: 412,/n      data: JSON.stringify({/n        success: false,/n        error: \'Unable to verify payload signature\',/n      }),/n    };/n  }/n  const { errors: TestSubscriptionErrors, data: TestSubscriptionData } = payload;/n/n  if (TestSubscriptionErrors) {/n    console.error(TestSubscriptionErrors);/n  }/n/n  console.log(TestSubscriptionData);/n/n  /**/n   * If you want to unsubscribe from this webhook/n   * in order to stop receiving new events,/n   * simply return status 410, e.g.:/n   */n   * return {/n   *   statusCode: 410,/n   *   body: JSON.stringify(null),/n   *   headers: {/n   *     \'content-type\': \'application/json\',/n   *   },/n   * }/n   *//n/n  return {/n    statusCode: 200,/n    body: JSON.stringify({/n      successfullyProcessedIncomingWebhook: true,/n    }),/n    headers: {/n      \'content-type\': \'application/json\',/n    },/n  };/n};/n"'

## netlify graph function library (+runtime) codegen library [#custom-node-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [#custom-node-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [#custom-browser-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [#custom-browser-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Next.js-node-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [Next.js-node-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Next.js-browser-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [Next.js-browser-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Remix-node-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [Remix-node-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Remix-browser-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [Remix-browser-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [unknown-node-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [unknown-node-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [unknown-browser-javascript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [unknown-browser-javascript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [#custom-node-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [#custom-node-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [#custom-browser-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [#custom-browser-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Next.js-node-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [Next.js-node-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Next.js-browser-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [Next.js-browser-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Remix-node-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [Remix-node-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [Remix-browser-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [Remix-browser-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [unknown-node-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    import buffer from "buffer"␊
    import crypto from "crypto"␊
    import https from "https"␊
    import process from "process"␊
    ␊
    export const verifySignature = (input) => {␊
      const secret = input.secret␊
      const body = input.body␊
      const signature = input.signature␊
    ␊
      if (!signature) {␊
        console.error('Missing signature')␊
        return false␊
      }␊
    ␊
      const sig = {}␊
      for (const pair of signature.split(',')) {␊
        const [key, value] = pair.split('=')␊
        sig[key] = value␊
      }␊
    ␊
      if (!sig.t || !sig.hmac_sha256) {␊
        console.error('Invalid signature header')␊
        return false␊
      }␊
    ␊
      const hash = crypto␊
        .createHmac('sha256', secret)␊
        .update(sig.t)␊
        .update('.')␊
        .update(body)␊
        .digest('hex')␊
    ␊
      if (␊
        !crypto.timingSafeEqual(␊
          Buffer.from(hash, 'hex'),␊
          Buffer.from(sig.hmac_sha256, 'hex')␊
        )␊
      ) {␊
        console.error('Invalid signature')␊
        return false␊
      }␊
    ␊
      if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {␊
        console.error('Request is too old')␊
        return false␊
      }␊
    ␊
      return true␊
    }␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        "Content-Type": "application/json",␊
        "Content-Length": reqBody.length,␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: "POST",␊
        headers: headers,␊
        timeout: timeoutMs,␊
      };␊
    ␊
      const url = "https://graph.netlify.com/graphql?app_id=" + siteId;␊
    ␊
      const respBody = [];␊
    ␊
      return new Promise((resolve, reject) => {␊
        const req = https.request(url, reqOptions, (res) => {␊
          if (res.statusCode && (res.statusCode < 200 || res.statusCode > 299) && res.statusCode !== 304) {␊
            return reject(␊
              new Error(␊
                "Netlify Graph return non-OK HTTP status code" + res.statusCode␊
              )␊
            );␊
          }␊
    ␊
          res.on("data", (chunk) => respBody.push(chunk));␊
    ␊
          res.on("end", () => {␊
            const resString = buffer.Buffer.concat(respBody).toString();␊
            resolve({␊
              status: res.statusCode,␊
              body: resString,␊
              headers: res.headers,␊
            });␊
          });␊
        });␊
    ␊
        req.on("error", (error) => {␊
          console.error("Error making request to Netlify Graph:", error);␊
        });␊
    ␊
        req.on("timeout", () => {␊
          req.destroy();␊
          reject(new Error("Request to Netlify Graph timed out"));␊
        });␊
    ␊
        req.write(reqBody);␊
        req.end();␊
      });␊
    };␊
    ␊
    ␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    export const verifyRequestSignature = (request, options) => {␊
      const event = request.event␊
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
      const signature = event.headers['x-netlify-graph-signature']␊
      const body = event.body␊
    ␊
      if (!secret) {␊
        console.error(␊
          'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'␊
        )␊
        return false␊
      }␊
    ␊
      return verifySignature({ secret, signature, body: body || '' })␊
    }␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery,␊
      /**␊
      * A subscription with variables and a fragment to test code generation.␊
      */␊
      subscribeToTestSubscription:subscribeToTestSubscription,␊
      /**␊
       * Verify the event body is signed securely, and then parse the result.␊
       */␊
      parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export default functions␊
    ␊
    export const handler = () => {␊
          // return a 401 json response␊
          return {␊
            statusCode: 401,␊
            body: JSON.stringify({␊
              message: 'Unauthorized',␊
            }),␊
          }␊
        }`

## netlify graph function library (+runtime) codegen [unknown-node-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,␊
      /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    subscribeToTestSubscription:subscribeToTestSubscription,␊
    /**␊
     * Verify the event body is signed securely, and then parse the result.␊
     */␊
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `

## netlify graph function library (+runtime) codegen library [unknown-browser-typescript-esm]:/netlifyGraph/index.js}

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // Basic LRU cache implementation␊
    const makeLRUCache = (max) => {␊
      return { max: max, cache: new Map() };␊
    };␊
    ␊
    const getFromCache = (lru, key) => {␊
      const item = lru.cache.get(key);␊
      if (item) {␊
        lru.cache.delete(key);␊
        lru.cache.set(key, item);␊
      }␊
      return item;␊
    };␊
    ␊
    const setInCache = (lru, key, value) => {␊
      if (lru.cache.has(key)) {␊
        lru.cache.delete(key);␊
      }␊
      if (lru.cache.size == lru.max) {␊
        lru.cache.delete(lru.first());␊
      }␊
      lru.cache.set(key, value);␊
    };␊
    ␊
    // Cache the results of the Netlify Graph API for conditional requests␊
    const cache = makeLRUCache(100);␊
    ␊
    const calculateCacheKey = (payload) => {␊
      return JSON.stringify(payload);␊
    };␊
    ␊
    ␊
    const httpFetch = (siteId, options) => {␊
      const reqBody = options.body || null;␊
      const userHeaders = options.headers || {};␊
      const headers = {␊
        ...userHeaders,␊
        'Content-Type': 'application/json',␊
      };␊
    ␊
      const timeoutMs = 30_000;␊
    ␊
      const reqOptions = {␊
        method: 'POST',␊
        headers: headers,␊
        timeout: timeoutMs,␊
        body: reqBody␊
      };␊
    ␊
      const url = 'https://graph.netlify.com/graphql?app_id=' + siteId;␊
    ␊
      return fetch(url, reqOptions).then(r => {␊
        body.text().then(bodyString => {␊
          const headers = {};␊
          r.headers.forEach((k,v) => x[k] = v);␊
          ␊
          return {␊
            body: bodyString,␊
            headers: headers,␊
            status: r.status␊
          }␊
        })␊
      });␊
    }␊
    ␊
    const fetchNetlifyGraph = function fetchNetlifyGraph(input) {␊
      const query = input.query;␊
      const docId = input.doc_id;␊
      const operationName = input.operationName;␊
      const variables = input.variables;␊
    ␊
      const options = input.options || {};␊
      const accessToken = options.accessToken;␊
      const siteId = options.siteId || process.env.SITE_ID;␊
    ␊
      const payload = {␊
        query: query,␊
        doc_id: docId,␊
        variables: variables,␊
        operationName: operationName,␊
      };␊
    ␊
      let cachedOrLiveValue = new Promise((resolve) => {␊
        const cacheKey = calculateCacheKey(payload);␊
    ␊
        // Check the cache for a previous result␊
        const cachedResultPair = getFromCache(cache, cacheKey);␊
    ␊
        let conditionalHeaders = {␊
          "If-None-Match": "",␊
        };␊
        let cachedResultValue;␊
    ␊
        if (cachedResultPair) {␊
          const [etag, previousResult] = cachedResultPair;␊
          conditionalHeaders = {␊
            "If-None-Match": etag,␊
          };␊
          cachedResultValue = previousResult;␊
        }␊
    ␊
        const response = httpFetch(siteId, {␊
          method: "POST",␊
          headers: {␊
            ...conditionalHeaders,␊
            Authorization: accessToken ? "Bearer " + accessToken : "",␊
          },␊
          body: JSON.stringify(payload),␊
        });␊
    ␊
        response.then((result) => {␊
          // Check response headers for a 304 Not Modified␊
          if (result.status === 304) {␊
            // Return the cached result␊
            resolve(cachedResultValue);␊
          } else if (result.status === 200) {␊
            // Update the cache with the new etag and result␊
            const etag = result.headers["etag"];␊
            const resultJson = JSON.parse(result.body)␊
              if (etag) {␊
                // Make a note of the new etag for the given payload␊
                setInCache(cache, cacheKey, [etag, resultJson]);␊
              }␊
              resolve(resultJson);␊
          } else {␊
            return result.json().then((json) => {␊
              resolve(json);␊
            });␊
          }␊
        });␊
      });␊
    ␊
      return cachedOrLiveValue;␊
    };␊
    ␊
    ␊
    ␊
    ␊
    export const executeUpdateCLISessionMetadataMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {␊
          session {␊
            id␊
            name␊
            metadata␊
            createdAt␊
            lastEventAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpdateCLISessionMetadataMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAppSchemaQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $appId) {␊
          graphQLSchema {␊
            appId␊
            createdAt␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
            updatedAt␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AppSchemaQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDestroyTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)␊
      }␊
    }\`,␊
            operationName: "DestroyTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSignOutServicesMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {␊
      signoutServices(␊
        data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}␊
      ) {␊
        me {␊
          serviceMetadata {␊
            loggedInServices {␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "SignOutServicesMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddAuthsMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {␊
      oneGraph {␊
        addAuthsToPersonalToken(␊
          input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}␊
        ) {␊
          accessToken {␊
            netlifyId␊
            token␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "AddAuthsMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateNewSchemaMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createGraphQLSchema(input: $input) {␊
          app {␊
            graphQLSchema {␊
              id␊
            }␊
          }␊
          graphqlSchema {␊
            id␊
            services {␊
              friendlyServiceName␊
              logoUrl␊
              service␊
              slug␊
              supportsCustomRedirectUri␊
              supportsCustomServiceAuth␊
              supportsOauthLogin␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateNewSchemaMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeDeleteServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "DeleteServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreatePersistedQueryMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersistedQuery(␊
          input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}␊
        ) {␊
          persistedQuery {␊
            id␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreatePersistedQueryMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchFindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        authlifyToken(authlifyTokenId: $authlifyTokenId) {␊
          serviceMetadata {␊
            loggedInServices {␊
              usedTestFlow␊
              friendlyServiceName␊
              ...LoggedInServicesFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeSetServiceAuthMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createServiceAuth(␊
          data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}␊
        ) {␊
          app {␊
            serviceAuths {␊
              ...ServiceAuthFragment␊
            }␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "SetServiceAuthMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateCLISessionEventMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createNetlifyCliTestEvent(␊
          input: {data: {payload: $payload}, sessionId: $sessionId}␊
        ) {␊
          event {␊
            id␊
            createdAt␊
            sessionId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateCLISessionEventMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionByIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSession(id: $id) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionByIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchDeprecated_FindLoggedInServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query Deprecated_FindLoggedInServicesQuery {␊
      me {␊
        serviceMetadata {␊
          loggedInServices {␊
            ...LoggedInServicesFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: """12b5bdea-9bab-4124-a731-5e697b1553be""", doc: """Subset of LoggedInServices""") {␊
      friendlyServiceName␊
      service␊
      isLoggedIn␊
      usedTestFlow␊
      serviceInfo {␊
        logoUrl␊
        availableScopes {␊
          category␊
          scope␊
          display␊
          isDefault␊
          isRequired␊
          description␊
          title␊
        }␊
      }␊
      grantedScopes {␊
        scope␊
      }␊
      foreignUserId␊
    }\`,␊
            operationName: "Deprecated_FindLoggedInServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeCreateEmptyPersonalTokenMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        createPersonalTokenWithNetlifySiteAnchor(␊
          input: {name: "Netlify AuthManager Token", netlifySiteId: $siteId}␊
        ) {␊
          accessToken {␊
            token␊
            name␊
            anchor␊
            netlifyId␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "CreateEmptyPersonalTokenMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchServiceListQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph {␊
        services {␊
          friendlyServiceName␊
          logoUrl(style: $logoStyle)␊
          service␊
          slug␊
          supportsCustomRedirectUri␊
          supportsCustomServiceAuth␊
          supportsOauthLogin␊
        }␊
      }␊
    }\`,␊
            operationName: "ServiceListQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchAuthlifyTokenIdForPersonalToken = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {␊
      oneGraph {␊
        personalToken(accessToken: $personalToken) {␊
          netlifyId␊
        }␊
      }␊
    }\`,␊
            operationName: "AuthlifyTokenIdForPersonalToken",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchPersistedQueryQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        persistedQuery(appId: $appId, id: $id) {␊
          id␊
          query␊
          allowedOperationNames␊
          description␊
          freeVariables␊
          fixedVariables␊
          tags␊
        }␊
      }␊
    }\`,␊
            operationName: "PersistedQueryQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCliSessionsByAppIdQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        netlifyCliSessionsByAppId(appId: $appId, first: 10) {␊
          id␊
          name␊
          netlifyUserId␊
          events {␊
            createdAt␊
          }␊
          createdAt␊
          lastEventAt␊
          metadata␊
        }␊
      }␊
    }\`,␊
            operationName: "CliSessionsByAppIdQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchListServicesQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        services(filter: {supportsOauthLogin: true}) {␊
          friendlyServiceName␊
          service␊
          slug␊
          logoUrl(style: $logoStyle)␊
          availableScopes {␊
            category␊
            scope␊
            display␊
            isDefault␊
            isRequired␊
            description␊
            title␊
          }␊
        }␊
        app(id: $siteId) {␊
          serviceAuths {␊
            ...ServiceAuthFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: """12b5bdea-9bab-4164-a731-5e697b1553be""", doc: """Basic info on a Service Auth""") {␊
      id␊
      service␊
      clientId␊
      revealTokens␊
      scopes␊
    }\`,␊
            operationName: "ListServicesQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeUpsertAppForSiteMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {␊
          org {␊
            id␊
            name␊
          }␊
          app {␊
            id␊
            name␊
            corsOrigins␊
            customCorsOrigins {␊
              friendlyServiceName␊
              displayName␊
              encodedValue␊
            }␊
          }␊
        }␊
      }␊
    }\`,␊
            operationName: "UpsertAppForSiteMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeAddCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        addCORSOriginToApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "AddCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const executeRemoveCORSOriginMutation  = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        removeCORSOriginFromApp(input: $input) {␊
          app {␊
            ...AppCORSOriginFragment␊
          }␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "RemoveCORSOriginMutation",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    export const fetchCORSOriginsQuery = (␊
          variables,␊
          options␊
        ) => {␊
          return fetchNetlifyGraph({␊
            query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {␊
      oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {␊
        app(id: $siteId) {␊
          ...AppCORSOriginFragment␊
        }␊
      }␊
    }␊
    ␊
    fragment AppCORSOriginFragment on OneGraphApp @netlify(id: """e3d4bb8b-2fb5-48d8-b051-db6027224145""", doc: """Allowed CORS origins for calls to a site's Graph.""") {␊
      id␊
      corsOrigins␊
      customCorsOrigins {␊
        friendlyServiceName␊
        displayName␊
        encodedValue␊
      }␊
      netlifySiteNames␊
    }\`,␊
            operationName: "CORSOriginsQuery",␊
            variables: variables,␊
            options: options,␊
            fetchStrategy: "POST",␊
          });␊
        }␊
    ␊
    ␊
    const subscribeToTestSubscription = (␊
      variables,␊
      rawOptions␊
      ) => {␊
        const options = rawOptions || {};␊
        const netlifyGraphWebhookId = options.netlifyGraphWebhookId;␊
        const netlifyGraphWebhookUrl = options.webhookUrl || \`${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=${netlifyGraphWebhookId}\`;␊
        const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET␊
        const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}␊
    ␊
        const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: """e3d4bb8b-2fb5-9898-b051-db6027224112""", doc: """A subscription with variables and a fragment to test code generation.""") {␊
      poll(␊
        schedule: {every: {minutes: $minutes}}␊
        onlyTriggerWhenPayloadChanged: true␊
        webhookUrl: $netlifyGraphWebhookUrl␊
        secret: $netlifyGraphWebhookSecret␊
      ) {␊
        query {␊
          me {␊
            serviceMetadata {␊
              loggedInServices {␊
                ...LoggedInServicesFragment␊
              }␊
            }␊
          }␊
        }␊
      }␊
    }\`;␊
    ␊
        fetchNetlifyGraph({␊
          query: subscriptionOperationDoc,␊
          operationName: "TestSubscription",␊
          variables: fullVariables,␊
          options: options,␊
          fetchStrategy: "POST",␊
      })␊
    }␊
    ␊
    const parseAndVerifyTestSubscriptionEvent = (event, options) => {␊
      if (!verifyRequestSignature({ event: event }, options)) {␊
        console.warn("Unable to verify signature for TestSubscription")␊
        return null␊
      }␊
    ␊
      return JSON.parse(event.body || '{}')␊
    }␊
    ␊
    /**␊
     * The generated NetlifyGraph library with your operations␊
     */␊
    const functions = {␊
      /**␊
      * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
      */␊
      executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,␊
      /**␊
      * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
      */␊
      fetchAppSchemaQuery: fetchAppSchemaQuery,␊
      /**␊
      * Delete a OneGraph personal token for a user's site␊
      */␊
      executeDestroyTokenMutation : executeDestroyTokenMutation ,␊
      /**␊
      * Sign out of a service associated with a Authlify token␊
      */␊
      executeSignOutServicesMutation : executeSignOutServicesMutation ,␊
      /**␊
      * Update a service's (i.e. GitHub) enabled scope permissions␊
      */␊
      executeAddAuthsMutation : executeAddAuthsMutation ,␊
      /**␊
      * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
      */␊
      executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,␊
      /**␊
      * Delete a custom service auth␊
      */␊
      executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,␊
      /**␊
      * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
      */␊
      executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,␊
      /**␊
      * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
      */␊
      fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,␊
      /**␊
      * Create a custom service auth␊
      */␊
      executeSetServiceAuthMutation : executeSetServiceAuthMutation ,␊
      /**␊
      * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
      */␊
      executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,␊
      /**␊
      * Get a Netlify CLI session by its id␊
      */␊
      fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,␊
      /**␊
      * (Deprecated) Find logged in services␊
      */␊
      fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
      * Create a new OneGraph personal token for a user's site␊
      */␊
      executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
      * Retrieve a list of _all_ supported services from OneGraph␊
      */␊
      fetchServiceListQuery: fetchServiceListQuery,␊
      /**␊
      * ␊
      */␊
      fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
      * Retrieve a previously persisted operations doc␊
      */␊
      fetchPersistedQueryQuery: fetchPersistedQueryQuery,␊
      /**␊
      * List all the CLI sessions belonging to a site␊
      */␊
      fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,␊
      /**␊
      * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
      */␊
      fetchListServicesQuery: fetchListServicesQuery,␊
      /**␊
      * Ensure that an app resource exists on the OneGraph servers for a given site.␊
      */␊
      executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,␊
      /**␊
      * Add additional allowed CORS origins for calls to a site's Graph.␊
      */␊
      executeAddCORSOriginMutation : executeAddCORSOriginMutation ,␊
      /**␊
      * Remove the given CORS origins for calls to a site's Graph.␊
      */␊
      executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,␊
      /**␊
      * List the allowed CORS origins for calls to a site's Graph.␊
      */␊
      fetchCORSOriginsQuery: fetchCORSOriginsQuery␊
    }␊
    ␊
    export default functions␊
    ␊
    `

## netlify graph function library (+runtime) codegen [unknown-browser-typescript-esm]:/netlifyGraph/index.d.ts

> Snapshot 1

    `/* eslint-disable */␊
    // @ts-nocheck␊
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!␊
    ␊
    export type NetlifyGraphFunctionOptions = {␊
      /**␊
       * The accessToken to use for the request␊
       */␊
      accessToken?: string;␊
      /**␊
       * The siteId to use for the request␊
       * @default process.env.SITE_ID␊
       */␊
      siteId?: string;␊
    }␊
    ␊
    export type WebhookEvent = {␊
      body: string;␊
      headers: Record<string, string | null | undefined>;␊
    };␊
    ␊
    export type GraphQLError = {␊
      "path": Array<string | number>;␊
      "message": string;␊
      "extensions": Record<string, unknown>;␊
    };␊
    ␊
    /**␊
    * Subset of LoggedInServices␊
    */␊
    export type LoggedInServicesFragment = {␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      isLoggedIn: boolean;␊
      usedTestFlow: boolean;␊
      serviceInfo: {␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    };␊
      /**␊
      * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.␊
      */␊
    grantedScopes?: Array<{␊
      /**␊
      * The name of the scope that the underlying service uses.␊
      */␊
    scope: string;␊
    }>;␊
      foreignUserId?: string;␊
    };␊
    ␊
    ␊
    /**␊
    * Basic info on a Service Auth␊
    */␊
    export type ServiceAuthFragment = {␊
      /**␊
      * id for the service auth␊
      */␊
    id: string;␊
      /**␊
      * The service that the clientId and clientSecret belong to, e.g. "gmail"␊
      */␊
    service: string;␊
      /**␊
      * clientId for the serviceAuth.␊
      */␊
    clientId: string;␊
      /**␊
      * If true, the bearer token that is created fetchable by the user whose account the token grants access to.␊
      */␊
    revealTokens: boolean;␊
      /**␊
      * Optional scopes to use for the OAuth flow.␊
      */␊
    scopes?: Array<string>;␊
    };␊
    ␊
    ␊
    /**␊
    * Allowed CORS origins for calls to a site's Graph.␊
    */␊
    export type AppCORSOriginFragment = {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
      /**␊
      * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.␊
      */␊
    netlifySiteNames: Array<string>;␊
    };␊
    ␊
    ␊
    export type UpdateCLISessionMetadataMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the session␊
     */␊
     "sessionId": string;  ␊
     /**␊
     * Optional metadata for the session␊
     */␊
     "metadata": unknown␊
    };␊
    ␊
    export type UpdateCLISessionMetadataMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Update a CLI session.␊
      */␊
    updateNetlifyCliSession: {␊
      /**␊
      * The session that was updated.␊
      */␊
    session: {␊
      id: string;␊
      name?: string;␊
      metadata?: unknown;␊
      createdAt: string;␊
      lastEventAt?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
     */␊
    export function executeUpdateCLISessionMetadataMutation (␊
      variables: UpdateCLISessionMetadataMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpdateCLISessionMetadataMutation>;␊
    ␊
    export type AppSchemaQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "appId": string␊
    };␊
    ␊
    export type AppSchemaQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      appId: string;␊
      createdAt: string;␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
      updatedAt: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
     */␊
    export function fetchAppSchemaQuery(␊
      variables: AppSchemaQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AppSchemaQuery>;␊
    ␊
    export type DestroyTokenMutationInput = {␊
     "nfToken": string;  ␊
     /**␊
     * Any OneGraph access token, refresh token, or JWT␊
     */␊
     "token"?: string;  ␊
     /**␊
     * An Authlify Token identifier␊
     */␊
     "authlifyTokenId"?: string␊
    };␊
    ␊
    export type DestroyTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.␊
    ␊
    If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.␊
      */␊
    destroyToken: boolean;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a OneGraph personal token for a user's site␊
     */␊
    export function executeDestroyTokenMutation (␊
      variables: DestroyTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DestroyTokenMutation>;␊
    ␊
    export type SignOutServicesMutationInput = {␊
     "services": Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">;  ␊
    "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type SignOutServicesMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      signoutServices: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Sign out of a service associated with a Authlify token␊
     */␊
    export function executeSignOutServicesMutation (␊
      variables: SignOutServicesMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SignOutServicesMutation>;␊
    ␊
    export type AddAuthsMutationInput = {␊
     "siteId": string;  ␊
    "authlifyTokenId"?: string;  ␊
     /**␊
     * Token that will be destroyed and have its auths moved to the personal token.␊
     */␊
     "sToken": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type AddAuthsMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addAuthsToPersonalToken: {␊
      /**␊
      * Personal access token that was updated by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Update a service's (i.e. GitHub) enabled scope permissions␊
     */␊
    export function executeAddAuthsMutation (␊
      variables: AddAuthsMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddAuthsMutation>;␊
    ␊
    export type CreateNewSchemaMutationInput = {␊
     "nfToken": string;  ␊
    "input": {/**␊
      * Whether to set this schema as the default for the app. Defaults to false.␊
      */␊
      "setAsDefaultForApp"?: boolean; /**␊
      * External GraphQL schemas to add␊
      */␊
      "externalGraphQLSchemas"?: Array<{/**␊
      * The id of the external GraphQL schema.␊
      */␊
      "externalGraphQLSchemaId": string}>; /**␊
      * Optional id of a Salesforce schema to attach to the app.␊
      */␊
      "salesforceSchemaId"?: string; /**␊
      * The optional id of the GraphQL schema that this was derived from.␊
      */␊
      "parentId"?: string; /**␊
      * The list of services that this schema should use. Leave blank if you want to add support for all supported services.␊
      */␊
      "enabledServices"?: Array<"ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS">; /**␊
      * The id of the app that the schema should belong to.␊
      */␊
      "appId": string}␊
    };␊
    ␊
    export type CreateNewSchemaMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createGraphQLSchema: {␊
      app: {␊
      /**␊
      * Customizations to the default GraphQL schema␊
      */␊
    graphQLSchema?: {␊
      id: string;␊
    };␊
    };␊
      graphqlSchema: {␊
      id: string;␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
     */␊
    export function executeCreateNewSchemaMutation (␊
      variables: CreateNewSchemaMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateNewSchemaMutation>;␊
    ␊
    export type DeleteServiceAuthMutationInput = {␊
     "siteId": string;  ␊
    "serviceAuthId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type DeleteServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      destroyServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Delete a custom service auth␊
     */␊
    export function executeDeleteServiceAuthMutation (␊
      variables: DeleteServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<DeleteServiceAuthMutation>;␊
    ␊
    export type CreatePersistedQueryMutationInput = {␊
     "nfToken": string;  ␊
    "appId": string;  ␊
    "query": string;  ␊
     /**␊
     * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.␊
     */␊
     "tags": Array<string>;  ␊
     /**␊
     * A description for the persisted query. Maximum length is 2096 characters.␊
     */␊
     "description": string;  ␊
     /**␊
     * The parent persisted query. It can be used to track lineage of the query.␊
     */␊
     "parent"?: {/**␊
      * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.␊
      */␊
      "removeTags"?: Array<string>; /**␊
      * The id of the parent␊
      */␊
      "id": string}␊
    };␊
    ␊
    export type CreatePersistedQueryMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createPersistedQuery: {␊
      persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
     */␊
    export function executeCreatePersistedQueryMutation (␊
      variables: CreatePersistedQueryMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreatePersistedQueryMutation>;␊
    ␊
    export type FindLoggedInServicesQueryInput = {␊
     "nfToken": string;  ␊
    "authlifyTokenId": string␊
    };␊
    ␊
    export type FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      authlifyToken: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment & {␊
      usedTestFlow: boolean;␊
      friendlyServiceName: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
     */␊
    export function fetchFindLoggedInServicesQuery(␊
      variables: FindLoggedInServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<FindLoggedInServicesQuery>;␊
    ␊
    export type SetServiceAuthMutationInput = {␊
     "service": "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK";  ␊
    "clientId": string;  ␊
    "clientSecret": string;  ␊
    "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type SetServiceAuthMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createServiceAuth: {␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a custom service auth␊
     */␊
    export function executeSetServiceAuthMutation (␊
      variables: SetServiceAuthMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<SetServiceAuthMutation>;␊
    ␊
    export type CreateCLISessionEventMutationInput = {␊
     "nfToken": string;  ␊
    "sessionId": string;  ␊
    "payload": unknown␊
    };␊
    ␊
    export type CreateCLISessionEventMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      createNetlifyCliTestEvent: {␊
      event: {␊
      id: string;␊
      createdAt: string;␊
      sessionId: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
     */␊
    export function executeCreateCLISessionEventMutation (␊
      variables: CreateCLISessionEventMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateCLISessionEventMutation>;␊
    ␊
    export type CliSessionByIdQueryInput = {␊
     "nfToken": string;  ␊
    "id": string␊
    };␊
    ␊
    export type CliSessionByIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Get a Netlify CLI session by its id.␊
      */␊
    netlifyCliSession: {␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Get a Netlify CLI session by its id␊
     */␊
    export function fetchCliSessionByIdQuery(␊
      variables: CliSessionByIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionByIdQuery>;␊
    ␊
    ␊
    export type Deprecated_FindLoggedInServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array<LoggedInServicesFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * (Deprecated) Find logged in services␊
     */␊
    export function fetchDeprecated_FindLoggedInServicesQuery(␊
      /**␊
      * Pass \`{}\` as no variables are defined for this function.␊
      */␊
      variables: Record<string, never>,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<Deprecated_FindLoggedInServicesQuery>;␊
    ␊
    export type CreateEmptyPersonalTokenMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type CreateEmptyPersonalTokenMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Creates an empty personal token with a Netlify site anchor␊
      */␊
    createPersonalTokenWithNetlifySiteAnchor: {␊
      /**␊
      * Personal access token that was created by this mutation␊
      */␊
    accessToken: {␊
      /**␊
      * Bearer token␊
      */␊
    token: string;␊
      /**␊
      * Token name, if it is a personal access token␊
      */␊
    name?: string;␊
      /**␊
      * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.␊
      */␊
    anchor?: "ONEGRAPH_USER" | "NETLIFY_USER" | "NETLIFY_SITE";␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Create a new OneGraph personal token for a user's site␊
     */␊
    export function executeCreateEmptyPersonalTokenMutation (␊
      variables: CreateEmptyPersonalTokenMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CreateEmptyPersonalTokenMutation>;␊
    ␊
    export type ServiceListQueryInput = {␊
     "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ServiceListQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      supportsCustomRedirectUri: boolean;␊
      supportsCustomServiceAuth: boolean;␊
      supportsOauthLogin: boolean;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a list of _all_ supported services from OneGraph␊
     */␊
    export function fetchServiceListQuery(␊
      variables: ServiceListQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ServiceListQuery>;␊
    ␊
    export type AuthlifyTokenIdForPersonalTokenInput = {␊
     "personalToken": string␊
    };␊
    ␊
    export type AuthlifyTokenIdForPersonalToken = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Personal access token lookup␊
      */␊
    personalToken?: {␊
      /**␊
      * Netlify-specific ID for the token␊
      */␊
    netlifyId?: string;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * ␊
     */␊
    export function fetchAuthlifyTokenIdForPersonalToken(␊
      variables: AuthlifyTokenIdForPersonalTokenInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AuthlifyTokenIdForPersonalToken>;␊
    ␊
    export type PersistedQueryQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * The id of the app that the persisted query belongs to.␊
     */␊
     "appId": string;  ␊
     /**␊
     * The id of the persisted query.␊
     */␊
     "id": string␊
    };␊
    ␊
    export type PersistedQueryQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Fetch a single persisted query by its id.␊
      */␊
    persistedQuery: {␊
      /**␊
      * The persisted query's id.␊
      */␊
    id: string;␊
      /**␊
      * The persisted query's query string.␊
      */␊
    query: string;␊
      /**␊
      * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.␊
      */␊
    allowedOperationNames?: Array<string>;␊
      /**␊
      * The user-defined description that was added to the query␊
      */␊
    description?: string;␊
      /**␊
      * The list of variables that the caller of the query is allowed to provide.␊
      */␊
    freeVariables?: Array<string>;␊
      /**␊
      * The default variables provided to the query.␊
      */␊
    fixedVariables?: unknown;␊
      /**␊
      * The list of user-defined tags that were added to the query␊
      */␊
    tags?: Array<string>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Retrieve a previously persisted operations doc␊
     */␊
    export function fetchPersistedQueryQuery(␊
      variables: PersistedQueryQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<PersistedQueryQuery>;␊
    ␊
    export type CliSessionsByAppIdQueryInput = {␊
     "nfToken": string;  ␊
    "appId": string␊
    };␊
    ␊
    export type CliSessionsByAppIdQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      /**␊
      * Netlify CLI sessions, orderd by createdAt descending.␊
      */␊
    netlifyCliSessionsByAppId: Array<{␊
      id: string;␊
      name?: string;␊
      netlifyUserId: string;␊
      events: Array<{␊
      createdAt: string;␊
    }>;␊
      createdAt: string;␊
      lastEventAt?: string;␊
      metadata?: unknown;␊
    }>;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List all the CLI sessions belonging to a site␊
     */␊
    export function fetchCliSessionsByAppIdQuery(␊
      variables: CliSessionsByAppIdQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CliSessionsByAppIdQuery>;␊
    ␊
    export type ListServicesQueryInput = {␊
     "nfToken": string;  ␊
     /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "logoStyle"?: "DEFAULT" | "ROUNDED_RECTANGLE"␊
    };␊
    ␊
    export type ListServicesQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      services: Array<{␊
      friendlyServiceName: string;␊
      service: "ADROLL" | "ASANA" | "BOX" | "CONTENTFUL" | "DEV_TO" | "DOCUSIGN" | "DRIBBBLE" | "DROPBOX" | "EGGHEADIO" | "EVENTIL" | "FACEBOOK" | "FIREBASE" | "GITHUB" | "GMAIL" | "GONG" | "GOOGLE" | "GOOGLE_ADS" | "GOOGLE_ANALYTICS" | "GOOGLE_CALENDAR" | "GOOGLE_COMPUTE" | "GOOGLE_DOCS" | "GOOGLE_SEARCH_CONSOLE" | "GOOGLE_TRANSLATE" | "HUBSPOT" | "INTERCOM" | "MAILCHIMP" | "MEETUP" | "NETLIFY" | "NOTION" | "OUTREACH" | "PRODUCT_HUNT" | "QUICKBOOKS" | "SALESFORCE" | "SANITY" | "SLACK" | "SPOTIFY" | "STRIPE" | "TRELLO" | "TWILIO" | "TWITTER" | "TWITCH_TV" | "YNAB" | "YOUTUBE" | "ZEIT" | "ZENDESK" | "AIRTABLE" | "APOLLO" | "BREX" | "BUNDLEPHOBIA" | "CHARGEBEE" | "CLEARBIT" | "CLOUDFLARE" | "CRUNCHBASE" | "DESCURI" | "FEDEX" | "GOOGLE_MAPS" | "GRAPHCMS" | "IMMIGRATION_GRAPH" | "LOGDNA" | "MIXPANEL" | "MUX" | "NPM" | "ONEGRAPH" | "ORBIT" | "OPEN_COLLECTIVE" | "RSS" | "UPS" | "USPS" | "WORDPRESS";␊
      /**␊
      * Service string that can be provided in the URL when going through the oauth flow.␊
      */␊
    slug: string;␊
      /**␊
      * A short-lived svg image url of the logo for the service. May be null.␊
      */␊
    logoUrl?: string;␊
      availableScopes?: Array<{␊
      category?: string;␊
      scope: string;␊
      display: string;␊
      isDefault: boolean;␊
      isRequired: boolean;␊
      description: string;␊
      title?: string;␊
    }>;␊
    }>;␊
      app: {␊
      /**␊
      * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app␊
      */␊
    serviceAuths: Array<ServiceAuthFragment>;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
     */␊
    export function fetchListServicesQuery(␊
      variables: ListServicesQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<ListServicesQuery>;␊
    ␊
    export type UpsertAppForSiteMutationInput = {␊
     "nfToken": string;  ␊
    "siteId": string␊
    };␊
    ␊
    export type UpsertAppForSiteMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      upsertAppForNetlifySite: {␊
      /**␊
      * The app that is associated with the Netlify account.␊
      */␊
    org: {␊
      /**␊
      * The id of the OneGraph Org␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph Org␊
      */␊
    name: string;␊
    };␊
      /**␊
      * The app that is associated with the Netlify site.␊
      */␊
    app: {␊
      /**␊
      * The id of the OneGraph App␊
      */␊
    id: string;␊
      /**␊
      * The name of the OneGraph App␊
      */␊
    name: string;␊
      /**␊
      * The origins allowed for this OneGraph App from CORS requests␊
      */␊
    corsOrigins: Array<string>;␊
      /**␊
      * Custom cors origins␊
      */␊
    customCorsOrigins: Array<{␊
      /**␊
      * The friendly service name for the cors origin␊
      */␊
    friendlyServiceName: string;␊
      /**␊
      * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.␊
      */␊
    displayName: string;␊
      /**␊
      * The encoded value as a string, used to remove the custom cors origin.␊
      */␊
    encodedValue: string;␊
    }>;␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Ensure that an app resource exists on the OneGraph servers for a given site.␊
     */␊
    export function executeUpsertAppForSiteMutation (␊
      variables: UpsertAppForSiteMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<UpsertAppForSiteMutation>;␊
    ␊
    export type AddCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type AddCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      addCORSOriginToApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Add additional allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function executeAddCORSOriginMutation (␊
      variables: AddCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<AddCORSOriginMutation>;␊
    ␊
    export type RemoveCORSOriginMutationInput = {␊
     "nfToken": string;  ␊
    "input": {"corsOrigin": string; "appId": string}␊
    };␊
    ␊
    export type RemoveCORSOriginMutation = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      removeCORSOriginFromApp: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * Remove the given CORS origins for calls to a site's Graph.␊
     */␊
    export function executeRemoveCORSOriginMutation (␊
      variables: RemoveCORSOriginMutationInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<RemoveCORSOriginMutation>;␊
    ␊
    export type CORSOriginsQueryInput = {␊
      /**␊
     * App id␊
     */␊
     "siteId": string;  ␊
    "nfToken": string␊
    };␊
    ␊
    export type CORSOriginsQuery = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      oneGraph: {␊
      app: AppCORSOriginFragment;␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    };␊
    ␊
    /**␊
     * List the allowed CORS origins for calls to a site's Graph.␊
     */␊
    export function fetchCORSOriginsQuery(␊
      variables: CORSOriginsQueryInput,␊
      options?: NetlifyGraphFunctionOptions␊
    ): Promise<CORSOriginsQuery>;␊
    ␊
    /**␊
    * A subscription with variables and a fragment to test code generation.␊
    */␊
    export function subscribeToTestSubscription(␊
      /**␊
       * This will be available in your webhook handler as a query parameter.␊
       * Use this to keep track of which subscription you're receiving␊
       * events for.␊
       */␊
      variables: {␊
      /**␊
     * How many minutes to wait before re-running the underlying query␊
     */␊
     "minutes"?: number␊
    },␊
      options?: {␊
        /**␊
         * The accessToken to use for the lifetime of the subscription.␊
         */␊
        accessToken?: string | null | undefined;␊
        /**␊
         * A string id that will be passed to your webhook handler as a query parameter␊
         * along with each event.␊
         * This can be used to keep track of which subscription you're receiving␊
         */␊
        netlifyGraphWebhookId?: string | null | undefined;␊
        /**␊
         * The absolute URL of your webhook handler to handle events from this subscription.␊
         */␊
        webhookUrl?: string | null | undefined;␊
        /**␊
         * The secret to use when signing the webhook request. Use this to verify␊
         * that the webhook payload is coming from Netlify Graph. Defaults to the␊
         * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.␊
         */␊
        webhookSecret?: string | null | undefined;␊
      }) : void␊
    ␊
    export type TestSubscriptionEvent = {␊
      /**␊
      * Any data from the function will be returned here␊
      */␊
    data: {␊
      poll: {␊
      query: {␊
      me: {␊
      /**␊
      * Metadata and logged-in state for all OneGraph services␊
      */␊
    serviceMetadata: {␊
      loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;␊
    };␊
    };␊
    };␊
    };␊
    };␊
      /**␊
      * Any errors from the function will be returned here␊
      */␊
    errors?: Array<GraphQLError>;␊
    }␊
    ␊
    /**␊
     * Verify the TestSubscription event body is signed securely, and then parse the result.␊
     */␊
    export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent␊
    ␊
    ␊
    export interface Functions {␊
      /**␊
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).␊
    */␊
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,␊
      /**␊
    * Get the _metadata_ about a site's current GraphQL schema:␊
    * ␊
    * - enabled services␊
    * - schema id␊
    * - creation date␊
    * ␊
    * etc.␊
    */␊
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,␊
      /**␊
    * Delete a OneGraph personal token for a user's site␊
    */␊
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,␊
      /**␊
    * Sign out of a service associated with a Authlify token␊
    */␊
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,␊
      /**␊
    * Update a service's (i.e. GitHub) enabled scope permissions␊
    */␊
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,␊
      /**␊
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.␊
    */␊
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,␊
      /**␊
    * Delete a custom service auth␊
    */␊
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,␊
      /**␊
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.␊
    */␊
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,␊
      /**␊
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site␊
    */␊
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,␊
      /**␊
    * Create a custom service auth␊
    */␊
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,␊
      /**␊
    * Create a new session for the Netlify CLI to communicate with the React UI via events.␊
    */␊
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,␊
      /**␊
    * Get a Netlify CLI session by its id␊
    */␊
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,␊
      /**␊
    * (Deprecated) Find logged in services␊
    */␊
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,␊
      /**␊
    * Create a new OneGraph personal token for a user's site␊
    */␊
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,␊
      /**␊
    * Retrieve a list of _all_ supported services from OneGraph␊
    */␊
    fetchServiceListQuery: typeof fetchServiceListQuery,␊
      /**␊
    * ␊
    */␊
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,␊
      /**␊
    * Retrieve a previously persisted operations doc␊
    */␊
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,␊
      /**␊
    * List all the CLI sessions belonging to a site␊
    */␊
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,␊
      /**␊
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.␊
    */␊
    fetchListServicesQuery: typeof fetchListServicesQuery,␊
      /**␊
    * Ensure that an app resource exists on the OneGraph servers for a given site.␊
    */␊
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,␊
      /**␊
    * Add additional allowed CORS origins for calls to a site's Graph.␊
    */␊
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,␊
      /**␊
    * Remove the given CORS origins for calls to a site's Graph.␊
    */␊
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,␊
      /**␊
    * List the allowed CORS origins for calls to a site's Graph.␊
    */␊
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery␊
    }␊
    ␊
    export const functions: Functions;␊
    ␊
    export default functions;␊
    `
