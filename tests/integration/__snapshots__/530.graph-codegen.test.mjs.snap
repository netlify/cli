// Vitest Snapshot v1

exports[`netlify graph function library runtime codegen library [netlify-builtin:nextjs-0.0.1]:./dummy/index.d.ts} 1`] = `
"/* eslint-disable */
    // @ts-nocheck
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
    
    export type NetlifyGraphFunctionOptions = {
      /**
       * The accessToken to use for the request
       */
      accessToken?: string;
      /**
       * The siteId to use for the request
       * @default process.env.SITE_ID
       */
      siteId?: string;
    }
    
    export type WebhookEvent = {
      body: string;
      headers: Record<string, string | null | undefined>;
    };
    
    export type GraphQLError = {
      \\"path\\": Array<string | number>;
      \\"message\\": string;
      \\"extensions\\": Record<string, unknown>;
    };
    
    /**
    * Subset of LoggedInServices
    */
    export type LoggedInServicesFragment = {
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  isLoggedIn: boolean;
  usedTestFlow: boolean;
  serviceInfo: {
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
};
  /**
  * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.
  */
grantedScopes?: Array<{
  /**
  * The name of the scope that the underlying service uses.
  */
scope: string;
}>;
  foreignUserId?: string;
};
    

/**
    * Basic info on a Service Auth
    */
    export type ServiceAuthFragment = {
  /**
  * id for the service auth
  */
id: string;
  /**
  * The service that the clientId and clientSecret belong to, e.g. \\"gmail\\"
  */
service: string;
  /**
  * clientId for the serviceAuth.
  */
clientId: string;
  /**
  * If true, the bearer token that is created fetchable by the user whose account the token grants access to.
  */
revealTokens: boolean;
  /**
  * Optional scopes to use for the OAuth flow.
  */
scopes?: Array<string>;
};
    

/**
    * Allowed CORS origins for calls to a site's Graph.
    */
    export type AppCORSOriginFragment = {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
  /**
  * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.
  */
netlifySiteNames: Array<string>;
};
    
    
    export type UpdateCLISessionMetadataMutationInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the session
 */
 \\"sessionId\\": string;  
 /**
 * Optional metadata for the session
 */
 \\"metadata\\": unknown
};
    
    export type UpdateCLISessionMetadataMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Update a CLI session.
  */
updateNetlifyCliSession: {
  /**
  * The session that was updated.
  */
session: {
  id: string;
  name?: string;
  metadata?: unknown;
  createdAt: string;
  lastEventAt?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
     */
    export function executeUpdateCLISessionMetadataMutation (
      variables: UpdateCLISessionMetadataMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpdateCLISessionMetadataMutation>;

export type AppSchemaQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"appId\\": string
};
    
    export type AppSchemaQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  appId: string;
  createdAt: string;
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
  updatedAt: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
     */
    export function fetchAppSchemaQuery(
      variables: AppSchemaQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AppSchemaQuery>;

export type DestroyTokenMutationInput = {
 \\"nfToken\\": string;  
 /**
 * Any OneGraph access token, refresh token, or JWT
 */
 \\"token\\"?: string;  
 /**
 * An Authlify Token identifier
 */
 \\"authlifyTokenId\\"?: string
};
    
    export type DestroyTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.

If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.
  */
destroyToken: boolean;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a OneGraph personal token for a user's site
     */
    export function executeDestroyTokenMutation (
      variables: DestroyTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DestroyTokenMutation>;

export type SignOutServicesMutationInput = {
 \\"services\\": Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">;  
\\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type SignOutServicesMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  signoutServices: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Sign out of a service associated with a Authlify token
     */
    export function executeSignOutServicesMutation (
      variables: SignOutServicesMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SignOutServicesMutation>;

export type AddAuthsMutationInput = {
 \\"siteId\\": string;  
\\"authlifyTokenId\\"?: string;  
 /**
 * Token that will be destroyed and have its auths moved to the personal token.
 */
 \\"sToken\\": string;  
\\"nfToken\\": string
};
    
    export type AddAuthsMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addAuthsToPersonalToken: {
  /**
  * Personal access token that was updated by this mutation
  */
accessToken: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
  /**
  * Bearer token
  */
token: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Update a service's (i.e. GitHub) enabled scope permissions
     */
    export function executeAddAuthsMutation (
      variables: AddAuthsMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddAuthsMutation>;

export type CreateNewSchemaMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {/**
  * Whether to set this schema as the default for the app. Defaults to false.
  */
  \\"setAsDefaultForApp\\"?: boolean; /**
  * External GraphQL schemas to add
  */
  \\"externalGraphQLSchemas\\"?: Array<{/**
  * The id of the external GraphQL schema.
  */
  \\"externalGraphQLSchemaId\\": string}>; /**
  * Optional id of a Salesforce schema to attach to the app.
  */
  \\"salesforceSchemaId\\"?: string; /**
  * The optional id of the GraphQL schema that this was derived from.
  */
  \\"parentId\\"?: string; /**
  * The list of services that this schema should use. Leave blank if you want to add support for all supported services.
  */
  \\"enabledServices\\"?: Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">; /**
  * The id of the app that the schema should belong to.
  */
  \\"appId\\": string}
};
    
    export type CreateNewSchemaMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createGraphQLSchema: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  id: string;
};
};
  graphqlSchema: {
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
     */
    export function executeCreateNewSchemaMutation (
      variables: CreateNewSchemaMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateNewSchemaMutation>;

export type DeleteServiceAuthMutationInput = {
 \\"siteId\\": string;  
\\"serviceAuthId\\": string;  
\\"nfToken\\": string
};
    
    export type DeleteServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  destroyServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a custom service auth
     */
    export function executeDeleteServiceAuthMutation (
      variables: DeleteServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DeleteServiceAuthMutation>;

export type CreatePersistedQueryMutationInput = {
 \\"nfToken\\": string;  
\\"appId\\": string;  
\\"query\\": string;  
 /**
 * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.
 */
 \\"tags\\": Array<string>;  
 /**
 * A description for the persisted query. Maximum length is 2096 characters.
 */
 \\"description\\": string;  
 /**
 * The parent persisted query. It can be used to track lineage of the query.
 */
 \\"parent\\"?: {/**
  * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.
  */
  \\"removeTags\\"?: Array<string>; /**
  * The id of the parent
  */
  \\"id\\": string}
};
    
    export type CreatePersistedQueryMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createPersistedQuery: {
  persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
     */
    export function executeCreatePersistedQueryMutation (
      variables: CreatePersistedQueryMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreatePersistedQueryMutation>;

export type FindLoggedInServicesQueryInput = {
 \\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  authlifyToken: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment & {
  usedTestFlow: boolean;
  friendlyServiceName: string;
} >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
     */
    export function fetchFindLoggedInServicesQuery(
      variables: FindLoggedInServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<FindLoggedInServicesQuery>;

export type SetServiceAuthMutationInput = {
 \\"service\\": \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\";  
\\"clientId\\": string;  
\\"clientSecret\\": string;  
\\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type SetServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a custom service auth
     */
    export function executeSetServiceAuthMutation (
      variables: SetServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SetServiceAuthMutation>;

export type CreateCLISessionEventMutationInput = {
 \\"nfToken\\": string;  
\\"sessionId\\": string;  
\\"payload\\": unknown
};
    
    export type CreateCLISessionEventMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createNetlifyCliTestEvent: {
  event: {
  id: string;
  createdAt: string;
  sessionId: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new session for the Netlify CLI to communicate with the React UI via events.
     */
    export function executeCreateCLISessionEventMutation (
      variables: CreateCLISessionEventMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateCLISessionEventMutation>;

export type CliSessionByIdQueryInput = {
 \\"nfToken\\": string;  
\\"id\\": string
};
    
    export type CliSessionByIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Get a Netlify CLI session by its id.
  */
netlifyCliSession: {
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get a Netlify CLI session by its id
     */
    export function fetchCliSessionByIdQuery(
      variables: CliSessionByIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionByIdQuery>;


    export type Deprecated_FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * (Deprecated) Find logged in services
     */
    export function fetchDeprecated_FindLoggedInServicesQuery(
      /**
      * Pass \`{}\` as no variables are defined for this function.
      */
      variables: Record<string, never>,
      options?: NetlifyGraphFunctionOptions
    ): Promise<Deprecated_FindLoggedInServicesQuery>;

export type CreateEmptyPersonalTokenMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type CreateEmptyPersonalTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Creates an empty personal token with a Netlify site anchor
  */
createPersonalTokenWithNetlifySiteAnchor: {
  /**
  * Personal access token that was created by this mutation
  */
accessToken: {
  /**
  * Bearer token
  */
token: string;
  /**
  * Token name, if it is a personal access token
  */
name?: string;
  /**
  * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.
  */
anchor?: \\"ONEGRAPH_USER\\" | \\"NETLIFY_USER\\" | \\"NETLIFY_SITE\\";
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new OneGraph personal token for a user's site
     */
    export function executeCreateEmptyPersonalTokenMutation (
      variables: CreateEmptyPersonalTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateEmptyPersonalTokenMutation>;

export type ServiceListQueryInput = {
 \\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ServiceListQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a list of _all_ supported services from OneGraph
     */
    export function fetchServiceListQuery(
      variables: ServiceListQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ServiceListQuery>;

export type AuthlifyTokenIdForPersonalTokenInput = {
 \\"personalToken\\": string
};
    
    export type AuthlifyTokenIdForPersonalToken = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Personal access token lookup
  */
personalToken?: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * 
     */
    export function fetchAuthlifyTokenIdForPersonalToken(
      variables: AuthlifyTokenIdForPersonalTokenInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AuthlifyTokenIdForPersonalToken>;

export type PersistedQueryQueryInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the app that the persisted query belongs to.
 */
 \\"appId\\": string;  
 /**
 * The id of the persisted query.
 */
 \\"id\\": string
};
    
    export type PersistedQueryQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Fetch a single persisted query by its id.
  */
persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
  /**
  * The persisted query's query string.
  */
query: string;
  /**
  * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.
  */
allowedOperationNames?: Array<string>;
  /**
  * The user-defined description that was added to the query
  */
description?: string;
  /**
  * The list of variables that the caller of the query is allowed to provide.
  */
freeVariables?: Array<string>;
  /**
  * The default variables provided to the query.
  */
fixedVariables?: unknown;
  /**
  * The list of user-defined tags that were added to the query
  */
tags?: Array<string>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a previously persisted operations doc
     */
    export function fetchPersistedQueryQuery(
      variables: PersistedQueryQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<PersistedQueryQuery>;

export type CliSessionsByAppIdQueryInput = {
 \\"nfToken\\": string;  
\\"appId\\": string
};
    
    export type CliSessionsByAppIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Netlify CLI sessions, orderd by createdAt descending.
  */
netlifyCliSessionsByAppId: Array<{
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List all the CLI sessions belonging to a site
     */
    export function fetchCliSessionsByAppIdQuery(
      variables: CliSessionsByAppIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionsByAppIdQuery>;

export type ListServicesQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"siteId\\": string;  
\\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ListServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
}>;
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
     */
    export function fetchListServicesQuery(
      variables: ListServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ListServicesQuery>;

export type UpsertAppForSiteMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type UpsertAppForSiteMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  upsertAppForNetlifySite: {
  /**
  * The app that is associated with the Netlify account.
  */
org: {
  /**
  * The id of the OneGraph Org
  */
id: string;
  /**
  * The name of the OneGraph Org
  */
name: string;
};
  /**
  * The app that is associated with the Netlify site.
  */
app: {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The name of the OneGraph App
  */
name: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Ensure that an app resource exists on the OneGraph servers for a given site.
     */
    export function executeUpsertAppForSiteMutation (
      variables: UpsertAppForSiteMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpsertAppForSiteMutation>;

export type AddCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type AddCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addCORSOriginToApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Add additional allowed CORS origins for calls to a site's Graph.
     */
    export function executeAddCORSOriginMutation (
      variables: AddCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddCORSOriginMutation>;

export type RemoveCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type RemoveCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  removeCORSOriginFromApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Remove the given CORS origins for calls to a site's Graph.
     */
    export function executeRemoveCORSOriginMutation (
      variables: RemoveCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<RemoveCORSOriginMutation>;

export type CORSOriginsQueryInput = {
  /**
 * App id
 */
 \\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type CORSOriginsQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: AppCORSOriginFragment ;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List the allowed CORS origins for calls to a site's Graph.
     */
    export function fetchCORSOriginsQuery(
      variables: CORSOriginsQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CORSOriginsQuery>;

/**
  * A subscription with variables and a fragment to test code generation.
  */
  export function subscribeToTestSubscription(
    /**
     * This will be available in your webhook handler as a query parameter.
     * Use this to keep track of which subscription you're receiving
     * events for.
     */
    variables: {
  /**
 * How many minutes to wait before re-running the underlying query
 */
 \\"minutes\\"?: number
},
    options?: {
      /**
       * The accessToken to use for the lifetime of the subscription.
       */
      accessToken?: string | null | undefined;
      /**
       * A string id that will be passed to your webhook handler as a query parameter
       * along with each event.
       * This can be used to keep track of which subscription you're receiving
       */
      netlifyGraphWebhookId?: string | null | undefined;
      /**
       * The absolute URL of your webhook handler to handle events from this subscription.
       */
      webhookUrl?: string | null | undefined;
      /**
       * The secret to use when signing the webhook request. Use this to verify
       * that the webhook payload is coming from Netlify Graph. Defaults to the
       * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.
       */
      webhookSecret?: string | null | undefined;
    }) : void
  
  export type TestSubscriptionEvent = {
  /**
  * Any data from the function will be returned here
  */
data: {
  poll: {
  query: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;
};
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
}
  
  /**
   * Verify the TestSubscription event body is signed securely, and then parse the result.
   */
  export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent
  
    
    export interface Functions {
      /**
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
    */
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,
  /**
    * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
    */
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,
  /**
    * Delete a OneGraph personal token for a user's site
    */
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,
  /**
    * Sign out of a service associated with a Authlify token
    */
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,
  /**
    * Update a service's (i.e. GitHub) enabled scope permissions
    */
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,
  /**
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
    */
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,
  /**
    * Delete a custom service auth
    */
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,
  /**
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
    */
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,
  /**
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
    */
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,
  /**
    * Create a custom service auth
    */
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,
  /**
    * Create a new session for the Netlify CLI to communicate with the React UI via events.
    */
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,
  /**
    * Get a Netlify CLI session by its id
    */
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,
  /**
    * (Deprecated) Find logged in services
    */
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,
  /**
    * Create a new OneGraph personal token for a user's site
    */
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,
  /**
    * Retrieve a list of _all_ supported services from OneGraph
    */
    fetchServiceListQuery: typeof fetchServiceListQuery,
  /**
    * 
    */
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,
  /**
    * Retrieve a previously persisted operations doc
    */
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,
  /**
    * List all the CLI sessions belonging to a site
    */
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,
  /**
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
    */
    fetchListServicesQuery: typeof fetchListServicesQuery,
  /**
    * Ensure that an app resource exists on the OneGraph servers for a given site.
    */
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,
  /**
    * Add additional allowed CORS origins for calls to a site's Graph.
    */
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,
  /**
    * Remove the given CORS origins for calls to a site's Graph.
    */
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,
  /**
    * List the allowed CORS origins for calls to a site's Graph.
    */
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,
  /**
    * A subscription with variables and a fragment to test code generation.
    */
    subscribeToTestSubscription:subscribeToTestSubscription,
    /**
     * Verify the event body is signed securely, and then parse the result.
     */
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent
    }
    
    export const functions: Functions;
    
    export default functions;
    "
`;

exports[`netlify graph function library runtime codegen library [netlify-builtin:nextjs-0.0.1]:./dummy/index.js} 1`] = `
"/* eslint-disable */
  // @ts-nocheck
  // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
  
  // Basic LRU cache implementation
  const makeLRUCache = (max) => {
    return { max: max, cache: new Map() };
  };
  
  const oldestCacheKey = (lru) => {
    return lru.keys().next().value
  }
  
  // Depend on Map keeping track of insertion order
  const getFromCache = (lru, key) => {
    const item = lru.cache.get(key);
    if (item) {
      // Delete key and re-insert so key is now at the end,
      // and now the last to be gc'd.
      lru.cache.delete(key);
      lru.cache.set(key, item);
    }
    return item;
  };
  
  const setInCache = (lru, key, value) => {
    if (lru.cache.has(key)) {
      lru.cache.delete(key);
    }
    if (lru.cache.size == lru.max) {
      const cacheKey = oldestCacheKey(lru);
  
      if (cacheKey) {
        lru.cache.delete(cacheKey);
      }
    }
  
    lru.cache.set(key, value);
  };
  
  // Cache the results of the Netlify Graph API for conditional requests
  const cache = makeLRUCache(100);
  
  const calculateCacheKey = (payload) => {
    return JSON.stringify(payload);
  };

  const schemaId = 'stable-schema-id';

  const netlifyGraphHostWithProtocol =
    process.env.NETLIFY_GRAPH_HOST_WITH_PROTOCOL || 'https://graph.netlify.com';

  const makeNetlifyGraphUrl = ({ operationName, siteId }) => {
    return (
      netlifyGraphHostWithProtocol +
      '/graphql?app_id=' +
      siteId +
      '&operationName=' +
      operationName +
      '&schema_id=' +
      schemaId
    );
  };

  const httpFetch = (operationName, options) => {
    const reqBody = options.body || null;
    const userHeaders = options.headers || {};
    const headers = {
      ...userHeaders,
      'Content-Type': 'application/json',
    };

    const timeoutMs = 30_000;

    const reqOptions = {
      method: 'POST',
      headers: headers,
      timeout: timeoutMs,
      body: reqBody,
    };

    const siteId = options.siteId || process.env.SITE_ID;
    const netlifyGraphUrl = makeNetlifyGraphUrl({ operationName: operationName, siteId: siteId });

    return fetch(netlifyGraphUrl, reqOptions).then((body) => {
      return body.text().then((bodyString) => {
        const headers = {};
        body.headers.forEach((k, v) => (headers[k] = v));
  
        return {
          body: bodyString,
          headers: headers,
          status: body.status,
        };
      });
    });
  };
 
  const fetchNetlifyGraph = function fetchNetlifyGraph(input) {
    const query = input.query;
    const docId = input.doc_id;
    const operationName = input.operationName;
    const variables = input.variables;
  
    const options = input.options || {};
    const accessToken = options.accessToken;
  
    const payload = {
      query: query,
      doc_id: docId,
      variables: variables,
      operationName: operationName,
    };
  
    let cachedOrLiveValue = new Promise((resolve) => {
      const cacheKey = calculateCacheKey(payload);
  
      // Check the cache for a previous result
      const cachedResultPair = getFromCache(cache, cacheKey);
  
      let conditionalHeaders = {
        'If-None-Match': '',
      };
      let cachedResultValue;
  
      if (cachedResultPair) {
        const [etag, previousResult] = cachedResultPair;
        conditionalHeaders = {
          'If-None-Match': etag,
        };
        cachedResultValue = previousResult;
      }
  
      const response = httpFetch(operationName, {
        ...options,
        method: 'POST',
        headers: {
          ...conditionalHeaders,
          Authorization: accessToken ? 'Bearer ' + accessToken : '',
        },
        body: JSON.stringify(payload),
      });
  
      response.then((result) => {
        // Check response headers for a 304 Not Modified
        if (result.status === 304) {
          // Return the cached result
          resolve(cachedResultValue);
        } else if (result.status === 200) {
          // Update the cache with the new etag and result
          const etag = result.headers['etag'];
          const resultJson = JSON.parse(result.body);
          if (etag) {
            // Make a note of the new etag for the given payload
            setInCache(cache, cacheKey, [etag, resultJson]);
          }
          resolve(resultJson);
        } else {
          return result.json().then((json) => {
            resolve(json);
          });
        }
      });
    });
  
    return cachedOrLiveValue;
  };

  export const executeUpdateCLISessionMetadataMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {
      session {
        id
        name
        metadata
        createdAt
        lastEventAt
      }
    }
  }
}\`,
        operationName: \\"UpdateCLISessionMetadataMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAppSchemaQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $appId) {
      graphQLSchema {
        appId
        createdAt
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
        updatedAt
      }
    }
  }
}\`,
        operationName: \\"AppSchemaQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDestroyTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)
  }
}\`,
        operationName: \\"DestroyTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSignOutServicesMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {
  signoutServices(
    data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}
  ) {
    me {
      serviceMetadata {
        loggedInServices {
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"SignOutServicesMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddAuthsMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {
  oneGraph {
    addAuthsToPersonalToken(
      input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}
    ) {
      accessToken {
        netlifyId
        token
      }
    }
  }
}\`,
        operationName: \\"AddAuthsMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateNewSchemaMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createGraphQLSchema(input: $input) {
      app {
        graphQLSchema {
          id
        }
      }
      graphqlSchema {
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
      }
    }
  }
}\`,
        operationName: \\"CreateNewSchemaMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDeleteServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"DeleteServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreatePersistedQueryMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersistedQuery(
      input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}
    ) {
      persistedQuery {
        id
      }
    }
  }
}\`,
        operationName: \\"CreatePersistedQueryMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchFindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    authlifyToken(authlifyTokenId: $authlifyTokenId) {
      serviceMetadata {
        loggedInServices {
          usedTestFlow
          friendlyServiceName
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSetServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createServiceAuth(
      data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}
    ) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"SetServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateCLISessionEventMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createNetlifyCliTestEvent(
      input: {data: {payload: $payload}, sessionId: $sessionId}
    ) {
      event {
        id
        createdAt
        sessionId
      }
    }
  }
}\`,
        operationName: \\"CreateCLISessionEventMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionByIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSession(id: $id) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionByIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchDeprecated_FindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query Deprecated_FindLoggedInServicesQuery {
  me {
    serviceMetadata {
      loggedInServices {
        ...LoggedInServicesFragment
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"Deprecated_FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateEmptyPersonalTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersonalTokenWithNetlifySiteAnchor(
      input: {name: \\"Netlify AuthManager Token\\", netlifySiteId: $siteId}
    ) {
      accessToken {
        token
        name
        anchor
        netlifyId
      }
    }
  }
}\`,
        operationName: \\"CreateEmptyPersonalTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchServiceListQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph {
    services {
      friendlyServiceName
      logoUrl(style: $logoStyle)
      service
      slug
      supportsCustomRedirectUri
      supportsCustomServiceAuth
      supportsOauthLogin
    }
  }
}\`,
        operationName: \\"ServiceListQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAuthlifyTokenIdForPersonalToken = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {
  oneGraph {
    personalToken(accessToken: $personalToken) {
      netlifyId
    }
  }
}\`,
        operationName: \\"AuthlifyTokenIdForPersonalToken\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchPersistedQueryQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    persistedQuery(appId: $appId, id: $id) {
      id
      query
      allowedOperationNames
      description
      freeVariables
      fixedVariables
      tags
    }
  }
}\`,
        operationName: \\"PersistedQueryQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionsByAppIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSessionsByAppId(appId: $appId, first: 10) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionsByAppIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchListServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    services(filter: {supportsOauthLogin: true}) {
      friendlyServiceName
      service
      slug
      logoUrl(style: $logoStyle)
      availableScopes {
        category
        scope
        display
        isDefault
        isRequired
        description
        title
      }
    }
    app(id: $siteId) {
      serviceAuths {
        ...ServiceAuthFragment
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"ListServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeUpsertAppForSiteMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {
      org {
        id
        name
      }
      app {
        id
        name
        corsOrigins
        customCorsOrigins {
          friendlyServiceName
          displayName
          encodedValue
        }
      }
    }
  }
}\`,
        operationName: \\"UpsertAppForSiteMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    addCORSOriginToApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"AddCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeRemoveCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    removeCORSOriginFromApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"RemoveCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCORSOriginsQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $siteId) {
      ...AppCORSOriginFragment
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"CORSOriginsQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

const subscribeToTestSubscription = (
    variables,
    rawOptions
    ) => {
      const options = rawOptions || {};
      const netlifyGraphWebhookId = options.netlifyGraphWebhookId;
      const netlifyGraphWebhookUrl = options.webhookUrl || \`\${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=\${netlifyGraphWebhookId}\`;
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET
      const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}
  
      const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-9898-b051-db6027224112\\"\\"\\", doc: \\"\\"\\"A subscription with variables and a fragment to test code generation.\\"\\"\\") {
  poll(
    schedule: {every: {minutes: $minutes}}
    onlyTriggerWhenPayloadChanged: true
    webhookUrl: $netlifyGraphWebhookUrl
    secret: $netlifyGraphWebhookSecret
  ) {
    query {
      me {
        serviceMetadata {
          loggedInServices {
            ...LoggedInServicesFragment
          }
        }
      }
    }
  }
}\`;
  
      fetchNetlifyGraph({
        query: subscriptionOperationDoc,
        operationName: \\"TestSubscription\\",
        variables: fullVariables,
        options: options,
        fetchStrategy: \\"POST\\",
    })
  }
  
  const parseAndVerifyTestSubscriptionEvent = (event, options) => {
    if (!verifyRequestSignature({ event: event }, options)) {
      console.warn(\\"Unable to verify signature for TestSubscription\\")
      return null
    }
  
    return JSON.parse(event.body || '{}')
  }
  
  /**
   * The generated NetlifyGraph library with your operations
   */
  const functions = {
    /**
  * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
  */
  executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,
  /**
  * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
  */
  fetchAppSchemaQuery: fetchAppSchemaQuery,
  /**
  * Delete a OneGraph personal token for a user's site
  */
  executeDestroyTokenMutation : executeDestroyTokenMutation ,
  /**
  * Sign out of a service associated with a Authlify token
  */
  executeSignOutServicesMutation : executeSignOutServicesMutation ,
  /**
  * Update a service's (i.e. GitHub) enabled scope permissions
  */
  executeAddAuthsMutation : executeAddAuthsMutation ,
  /**
  * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
  */
  executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,
  /**
  * Delete a custom service auth
  */
  executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,
  /**
  * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
  */
  executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,
  /**
  * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
  */
  fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,
  /**
  * Create a custom service auth
  */
  executeSetServiceAuthMutation : executeSetServiceAuthMutation ,
  /**
  * Create a new session for the Netlify CLI to communicate with the React UI via events.
  */
  executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,
  /**
  * Get a Netlify CLI session by its id
  */
  fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,
  /**
  * (Deprecated) Find logged in services
  */
  fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,
  /**
  * Create a new OneGraph personal token for a user's site
  */
  executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,
  /**
  * Retrieve a list of _all_ supported services from OneGraph
  */
  fetchServiceListQuery: fetchServiceListQuery,
  /**
  * 
  */
  fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,
  /**
  * Retrieve a previously persisted operations doc
  */
  fetchPersistedQueryQuery: fetchPersistedQueryQuery,
  /**
  * List all the CLI sessions belonging to a site
  */
  fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,
  /**
  * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
  */
  fetchListServicesQuery: fetchListServicesQuery,
  /**
  * Ensure that an app resource exists on the OneGraph servers for a given site.
  */
  executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,
  /**
  * Add additional allowed CORS origins for calls to a site's Graph.
  */
  executeAddCORSOriginMutation : executeAddCORSOriginMutation ,
  /**
  * Remove the given CORS origins for calls to a site's Graph.
  */
  executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,
  /**
  * List the allowed CORS origins for calls to a site's Graph.
  */
  fetchCORSOriginsQuery: fetchCORSOriginsQuery,
  /**
  * A subscription with variables and a fragment to test code generation.
  */
  subscribeToTestSubscription:subscribeToTestSubscription,
  /**
   * Verify the event body is signed securely, and then parse the result.
   */
  parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent
  }
  
  export default functions"
`;

exports[`netlify graph function library runtime codegen library [netlify-builtin:remix-0.0.1]:./dummy/index.d.ts} 1`] = `
"/* eslint-disable */
    // @ts-nocheck
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
    
    export type NetlifyGraphFunctionOptions = {
      /**
       * The accessToken to use for the request
       */
      accessToken?: string;
      /**
       * The siteId to use for the request
       * @default process.env.SITE_ID
       */
      siteId?: string;
    }
    
    export type WebhookEvent = {
      body: string;
      headers: Record<string, string | null | undefined>;
    };
    
    export type GraphQLError = {
      \\"path\\": Array<string | number>;
      \\"message\\": string;
      \\"extensions\\": Record<string, unknown>;
    };
    
    /**
    * Subset of LoggedInServices
    */
    export type LoggedInServicesFragment = {
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  isLoggedIn: boolean;
  usedTestFlow: boolean;
  serviceInfo: {
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
};
  /**
  * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.
  */
grantedScopes?: Array<{
  /**
  * The name of the scope that the underlying service uses.
  */
scope: string;
}>;
  foreignUserId?: string;
};
    

/**
    * Basic info on a Service Auth
    */
    export type ServiceAuthFragment = {
  /**
  * id for the service auth
  */
id: string;
  /**
  * The service that the clientId and clientSecret belong to, e.g. \\"gmail\\"
  */
service: string;
  /**
  * clientId for the serviceAuth.
  */
clientId: string;
  /**
  * If true, the bearer token that is created fetchable by the user whose account the token grants access to.
  */
revealTokens: boolean;
  /**
  * Optional scopes to use for the OAuth flow.
  */
scopes?: Array<string>;
};
    

/**
    * Allowed CORS origins for calls to a site's Graph.
    */
    export type AppCORSOriginFragment = {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
  /**
  * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.
  */
netlifySiteNames: Array<string>;
};
    
    
    export type UpdateCLISessionMetadataMutationInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the session
 */
 \\"sessionId\\": string;  
 /**
 * Optional metadata for the session
 */
 \\"metadata\\": unknown
};
    
    export type UpdateCLISessionMetadataMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Update a CLI session.
  */
updateNetlifyCliSession: {
  /**
  * The session that was updated.
  */
session: {
  id: string;
  name?: string;
  metadata?: unknown;
  createdAt: string;
  lastEventAt?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
     */
    export function executeUpdateCLISessionMetadataMutation (
      variables: UpdateCLISessionMetadataMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpdateCLISessionMetadataMutation>;

export type AppSchemaQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"appId\\": string
};
    
    export type AppSchemaQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  appId: string;
  createdAt: string;
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
  updatedAt: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
     */
    export function fetchAppSchemaQuery(
      variables: AppSchemaQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AppSchemaQuery>;

export type DestroyTokenMutationInput = {
 \\"nfToken\\": string;  
 /**
 * Any OneGraph access token, refresh token, or JWT
 */
 \\"token\\"?: string;  
 /**
 * An Authlify Token identifier
 */
 \\"authlifyTokenId\\"?: string
};
    
    export type DestroyTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.

If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.
  */
destroyToken: boolean;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a OneGraph personal token for a user's site
     */
    export function executeDestroyTokenMutation (
      variables: DestroyTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DestroyTokenMutation>;

export type SignOutServicesMutationInput = {
 \\"services\\": Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">;  
\\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type SignOutServicesMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  signoutServices: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Sign out of a service associated with a Authlify token
     */
    export function executeSignOutServicesMutation (
      variables: SignOutServicesMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SignOutServicesMutation>;

export type AddAuthsMutationInput = {
 \\"siteId\\": string;  
\\"authlifyTokenId\\"?: string;  
 /**
 * Token that will be destroyed and have its auths moved to the personal token.
 */
 \\"sToken\\": string;  
\\"nfToken\\": string
};
    
    export type AddAuthsMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addAuthsToPersonalToken: {
  /**
  * Personal access token that was updated by this mutation
  */
accessToken: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
  /**
  * Bearer token
  */
token: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Update a service's (i.e. GitHub) enabled scope permissions
     */
    export function executeAddAuthsMutation (
      variables: AddAuthsMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddAuthsMutation>;

export type CreateNewSchemaMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {/**
  * Whether to set this schema as the default for the app. Defaults to false.
  */
  \\"setAsDefaultForApp\\"?: boolean; /**
  * External GraphQL schemas to add
  */
  \\"externalGraphQLSchemas\\"?: Array<{/**
  * The id of the external GraphQL schema.
  */
  \\"externalGraphQLSchemaId\\": string}>; /**
  * Optional id of a Salesforce schema to attach to the app.
  */
  \\"salesforceSchemaId\\"?: string; /**
  * The optional id of the GraphQL schema that this was derived from.
  */
  \\"parentId\\"?: string; /**
  * The list of services that this schema should use. Leave blank if you want to add support for all supported services.
  */
  \\"enabledServices\\"?: Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">; /**
  * The id of the app that the schema should belong to.
  */
  \\"appId\\": string}
};
    
    export type CreateNewSchemaMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createGraphQLSchema: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  id: string;
};
};
  graphqlSchema: {
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
     */
    export function executeCreateNewSchemaMutation (
      variables: CreateNewSchemaMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateNewSchemaMutation>;

export type DeleteServiceAuthMutationInput = {
 \\"siteId\\": string;  
\\"serviceAuthId\\": string;  
\\"nfToken\\": string
};
    
    export type DeleteServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  destroyServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a custom service auth
     */
    export function executeDeleteServiceAuthMutation (
      variables: DeleteServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DeleteServiceAuthMutation>;

export type CreatePersistedQueryMutationInput = {
 \\"nfToken\\": string;  
\\"appId\\": string;  
\\"query\\": string;  
 /**
 * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.
 */
 \\"tags\\": Array<string>;  
 /**
 * A description for the persisted query. Maximum length is 2096 characters.
 */
 \\"description\\": string;  
 /**
 * The parent persisted query. It can be used to track lineage of the query.
 */
 \\"parent\\"?: {/**
  * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.
  */
  \\"removeTags\\"?: Array<string>; /**
  * The id of the parent
  */
  \\"id\\": string}
};
    
    export type CreatePersistedQueryMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createPersistedQuery: {
  persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
     */
    export function executeCreatePersistedQueryMutation (
      variables: CreatePersistedQueryMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreatePersistedQueryMutation>;

export type FindLoggedInServicesQueryInput = {
 \\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  authlifyToken: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment & {
  usedTestFlow: boolean;
  friendlyServiceName: string;
} >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
     */
    export function fetchFindLoggedInServicesQuery(
      variables: FindLoggedInServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<FindLoggedInServicesQuery>;

export type SetServiceAuthMutationInput = {
 \\"service\\": \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\";  
\\"clientId\\": string;  
\\"clientSecret\\": string;  
\\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type SetServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a custom service auth
     */
    export function executeSetServiceAuthMutation (
      variables: SetServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SetServiceAuthMutation>;

export type CreateCLISessionEventMutationInput = {
 \\"nfToken\\": string;  
\\"sessionId\\": string;  
\\"payload\\": unknown
};
    
    export type CreateCLISessionEventMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createNetlifyCliTestEvent: {
  event: {
  id: string;
  createdAt: string;
  sessionId: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new session for the Netlify CLI to communicate with the React UI via events.
     */
    export function executeCreateCLISessionEventMutation (
      variables: CreateCLISessionEventMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateCLISessionEventMutation>;

export type CliSessionByIdQueryInput = {
 \\"nfToken\\": string;  
\\"id\\": string
};
    
    export type CliSessionByIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Get a Netlify CLI session by its id.
  */
netlifyCliSession: {
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get a Netlify CLI session by its id
     */
    export function fetchCliSessionByIdQuery(
      variables: CliSessionByIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionByIdQuery>;


    export type Deprecated_FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * (Deprecated) Find logged in services
     */
    export function fetchDeprecated_FindLoggedInServicesQuery(
      /**
      * Pass \`{}\` as no variables are defined for this function.
      */
      variables: Record<string, never>,
      options?: NetlifyGraphFunctionOptions
    ): Promise<Deprecated_FindLoggedInServicesQuery>;

export type CreateEmptyPersonalTokenMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type CreateEmptyPersonalTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Creates an empty personal token with a Netlify site anchor
  */
createPersonalTokenWithNetlifySiteAnchor: {
  /**
  * Personal access token that was created by this mutation
  */
accessToken: {
  /**
  * Bearer token
  */
token: string;
  /**
  * Token name, if it is a personal access token
  */
name?: string;
  /**
  * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.
  */
anchor?: \\"ONEGRAPH_USER\\" | \\"NETLIFY_USER\\" | \\"NETLIFY_SITE\\";
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new OneGraph personal token for a user's site
     */
    export function executeCreateEmptyPersonalTokenMutation (
      variables: CreateEmptyPersonalTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateEmptyPersonalTokenMutation>;

export type ServiceListQueryInput = {
 \\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ServiceListQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a list of _all_ supported services from OneGraph
     */
    export function fetchServiceListQuery(
      variables: ServiceListQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ServiceListQuery>;

export type AuthlifyTokenIdForPersonalTokenInput = {
 \\"personalToken\\": string
};
    
    export type AuthlifyTokenIdForPersonalToken = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Personal access token lookup
  */
personalToken?: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * 
     */
    export function fetchAuthlifyTokenIdForPersonalToken(
      variables: AuthlifyTokenIdForPersonalTokenInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AuthlifyTokenIdForPersonalToken>;

export type PersistedQueryQueryInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the app that the persisted query belongs to.
 */
 \\"appId\\": string;  
 /**
 * The id of the persisted query.
 */
 \\"id\\": string
};
    
    export type PersistedQueryQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Fetch a single persisted query by its id.
  */
persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
  /**
  * The persisted query's query string.
  */
query: string;
  /**
  * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.
  */
allowedOperationNames?: Array<string>;
  /**
  * The user-defined description that was added to the query
  */
description?: string;
  /**
  * The list of variables that the caller of the query is allowed to provide.
  */
freeVariables?: Array<string>;
  /**
  * The default variables provided to the query.
  */
fixedVariables?: unknown;
  /**
  * The list of user-defined tags that were added to the query
  */
tags?: Array<string>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a previously persisted operations doc
     */
    export function fetchPersistedQueryQuery(
      variables: PersistedQueryQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<PersistedQueryQuery>;

export type CliSessionsByAppIdQueryInput = {
 \\"nfToken\\": string;  
\\"appId\\": string
};
    
    export type CliSessionsByAppIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Netlify CLI sessions, orderd by createdAt descending.
  */
netlifyCliSessionsByAppId: Array<{
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List all the CLI sessions belonging to a site
     */
    export function fetchCliSessionsByAppIdQuery(
      variables: CliSessionsByAppIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionsByAppIdQuery>;

export type ListServicesQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"siteId\\": string;  
\\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ListServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
}>;
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
     */
    export function fetchListServicesQuery(
      variables: ListServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ListServicesQuery>;

export type UpsertAppForSiteMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type UpsertAppForSiteMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  upsertAppForNetlifySite: {
  /**
  * The app that is associated with the Netlify account.
  */
org: {
  /**
  * The id of the OneGraph Org
  */
id: string;
  /**
  * The name of the OneGraph Org
  */
name: string;
};
  /**
  * The app that is associated with the Netlify site.
  */
app: {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The name of the OneGraph App
  */
name: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Ensure that an app resource exists on the OneGraph servers for a given site.
     */
    export function executeUpsertAppForSiteMutation (
      variables: UpsertAppForSiteMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpsertAppForSiteMutation>;

export type AddCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type AddCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addCORSOriginToApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Add additional allowed CORS origins for calls to a site's Graph.
     */
    export function executeAddCORSOriginMutation (
      variables: AddCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddCORSOriginMutation>;

export type RemoveCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type RemoveCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  removeCORSOriginFromApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Remove the given CORS origins for calls to a site's Graph.
     */
    export function executeRemoveCORSOriginMutation (
      variables: RemoveCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<RemoveCORSOriginMutation>;

export type CORSOriginsQueryInput = {
  /**
 * App id
 */
 \\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type CORSOriginsQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: AppCORSOriginFragment ;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List the allowed CORS origins for calls to a site's Graph.
     */
    export function fetchCORSOriginsQuery(
      variables: CORSOriginsQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CORSOriginsQuery>;

/**
  * A subscription with variables and a fragment to test code generation.
  */
  export function subscribeToTestSubscription(
    /**
     * This will be available in your webhook handler as a query parameter.
     * Use this to keep track of which subscription you're receiving
     * events for.
     */
    variables: {
  /**
 * How many minutes to wait before re-running the underlying query
 */
 \\"minutes\\"?: number
},
    options?: {
      /**
       * The accessToken to use for the lifetime of the subscription.
       */
      accessToken?: string | null | undefined;
      /**
       * A string id that will be passed to your webhook handler as a query parameter
       * along with each event.
       * This can be used to keep track of which subscription you're receiving
       */
      netlifyGraphWebhookId?: string | null | undefined;
      /**
       * The absolute URL of your webhook handler to handle events from this subscription.
       */
      webhookUrl?: string | null | undefined;
      /**
       * The secret to use when signing the webhook request. Use this to verify
       * that the webhook payload is coming from Netlify Graph. Defaults to the
       * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.
       */
      webhookSecret?: string | null | undefined;
    }) : void
  
  export type TestSubscriptionEvent = {
  /**
  * Any data from the function will be returned here
  */
data: {
  poll: {
  query: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;
};
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
}
  
  /**
   * Verify the TestSubscription event body is signed securely, and then parse the result.
   */
  export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent
  
    
    export interface Functions {
      /**
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
    */
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,
  /**
    * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
    */
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,
  /**
    * Delete a OneGraph personal token for a user's site
    */
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,
  /**
    * Sign out of a service associated with a Authlify token
    */
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,
  /**
    * Update a service's (i.e. GitHub) enabled scope permissions
    */
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,
  /**
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
    */
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,
  /**
    * Delete a custom service auth
    */
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,
  /**
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
    */
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,
  /**
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
    */
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,
  /**
    * Create a custom service auth
    */
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,
  /**
    * Create a new session for the Netlify CLI to communicate with the React UI via events.
    */
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,
  /**
    * Get a Netlify CLI session by its id
    */
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,
  /**
    * (Deprecated) Find logged in services
    */
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,
  /**
    * Create a new OneGraph personal token for a user's site
    */
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,
  /**
    * Retrieve a list of _all_ supported services from OneGraph
    */
    fetchServiceListQuery: typeof fetchServiceListQuery,
  /**
    * 
    */
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,
  /**
    * Retrieve a previously persisted operations doc
    */
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,
  /**
    * List all the CLI sessions belonging to a site
    */
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,
  /**
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
    */
    fetchListServicesQuery: typeof fetchListServicesQuery,
  /**
    * Ensure that an app resource exists on the OneGraph servers for a given site.
    */
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,
  /**
    * Add additional allowed CORS origins for calls to a site's Graph.
    */
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,
  /**
    * Remove the given CORS origins for calls to a site's Graph.
    */
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,
  /**
    * List the allowed CORS origins for calls to a site's Graph.
    */
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,
  /**
    * A subscription with variables and a fragment to test code generation.
    */
    subscribeToTestSubscription:subscribeToTestSubscription,
    /**
     * Verify the event body is signed securely, and then parse the result.
     */
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent
    }
    
    export const functions: Functions;
    
    export default functions;
    "
`;

exports[`netlify graph function library runtime codegen library [netlify-builtin:remix-0.0.1]:./dummy/index.js} 1`] = `
"/* eslint-disable */
  // @ts-nocheck
  // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
  
  // Basic LRU cache implementation
  const makeLRUCache = (max) => {
    return { max: max, cache: new Map() };
  };
  
  const oldestCacheKey = (lru) => {
    return lru.keys().next().value
  }
  
  // Depend on Map keeping track of insertion order
  const getFromCache = (lru, key) => {
    const item = lru.cache.get(key);
    if (item) {
      // Delete key and re-insert so key is now at the end,
      // and now the last to be gc'd.
      lru.cache.delete(key);
      lru.cache.set(key, item);
    }
    return item;
  };
  
  const setInCache = (lru, key, value) => {
    if (lru.cache.has(key)) {
      lru.cache.delete(key);
    }
    if (lru.cache.size == lru.max) {
      const cacheKey = oldestCacheKey(lru);
  
      if (cacheKey) {
        lru.cache.delete(cacheKey);
      }
    }
  
    lru.cache.set(key, value);
  };
  
  // Cache the results of the Netlify Graph API for conditional requests
  const cache = makeLRUCache(100);
  
  const calculateCacheKey = (payload) => {
    return JSON.stringify(payload);
  };

  const schemaId = 'stable-schema-id';

  const netlifyGraphHostWithProtocol =
    process.env.NETLIFY_GRAPH_HOST_WITH_PROTOCOL || 'https://graph.netlify.com';

  const makeNetlifyGraphUrl = ({ operationName, siteId }) => {
    return (
      netlifyGraphHostWithProtocol +
      '/graphql?app_id=' +
      siteId +
      '&operationName=' +
      operationName +
      '&schema_id=' +
      schemaId
    );
  };

  const httpFetch = (operationName, options) => {
    const reqBody = options.body || null;
    const userHeaders = options.headers || {};
    const headers = {
      ...userHeaders,
      'Content-Type': 'application/json',
    };

    const timeoutMs = 30_000;

    const reqOptions = {
      method: 'POST',
      headers: headers,
      timeout: timeoutMs,
      body: reqBody,
    };

    const siteId = options.siteId || process.env.SITE_ID;
    const netlifyGraphUrl = makeNetlifyGraphUrl({ operationName: operationName, siteId: siteId });

    return fetch(netlifyGraphUrl, reqOptions).then((body) => {
      return body.text().then((bodyString) => {
        const headers = {};
        body.headers.forEach((k, v) => (headers[k] = v));
  
        return {
          body: bodyString,
          headers: headers,
          status: body.status,
        };
      });
    });
  };
 
  const fetchNetlifyGraph = function fetchNetlifyGraph(input) {
    const query = input.query;
    const docId = input.doc_id;
    const operationName = input.operationName;
    const variables = input.variables;
  
    const options = input.options || {};
    const accessToken = options.accessToken;
  
    const payload = {
      query: query,
      doc_id: docId,
      variables: variables,
      operationName: operationName,
    };
  
    let cachedOrLiveValue = new Promise((resolve) => {
      const cacheKey = calculateCacheKey(payload);
  
      // Check the cache for a previous result
      const cachedResultPair = getFromCache(cache, cacheKey);
  
      let conditionalHeaders = {
        'If-None-Match': '',
      };
      let cachedResultValue;
  
      if (cachedResultPair) {
        const [etag, previousResult] = cachedResultPair;
        conditionalHeaders = {
          'If-None-Match': etag,
        };
        cachedResultValue = previousResult;
      }
  
      const response = httpFetch(operationName, {
        ...options,
        method: 'POST',
        headers: {
          ...conditionalHeaders,
          Authorization: accessToken ? 'Bearer ' + accessToken : '',
        },
        body: JSON.stringify(payload),
      });
  
      response.then((result) => {
        // Check response headers for a 304 Not Modified
        if (result.status === 304) {
          // Return the cached result
          resolve(cachedResultValue);
        } else if (result.status === 200) {
          // Update the cache with the new etag and result
          const etag = result.headers['etag'];
          const resultJson = JSON.parse(result.body);
          if (etag) {
            // Make a note of the new etag for the given payload
            setInCache(cache, cacheKey, [etag, resultJson]);
          }
          resolve(resultJson);
        } else {
          return result.json().then((json) => {
            resolve(json);
          });
        }
      });
    });
  
    return cachedOrLiveValue;
  };

  export const executeUpdateCLISessionMetadataMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {
      session {
        id
        name
        metadata
        createdAt
        lastEventAt
      }
    }
  }
}\`,
        operationName: \\"UpdateCLISessionMetadataMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAppSchemaQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $appId) {
      graphQLSchema {
        appId
        createdAt
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
        updatedAt
      }
    }
  }
}\`,
        operationName: \\"AppSchemaQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDestroyTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)
  }
}\`,
        operationName: \\"DestroyTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSignOutServicesMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {
  signoutServices(
    data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}
  ) {
    me {
      serviceMetadata {
        loggedInServices {
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"SignOutServicesMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddAuthsMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {
  oneGraph {
    addAuthsToPersonalToken(
      input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}
    ) {
      accessToken {
        netlifyId
        token
      }
    }
  }
}\`,
        operationName: \\"AddAuthsMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateNewSchemaMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createGraphQLSchema(input: $input) {
      app {
        graphQLSchema {
          id
        }
      }
      graphqlSchema {
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
      }
    }
  }
}\`,
        operationName: \\"CreateNewSchemaMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDeleteServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"DeleteServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreatePersistedQueryMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersistedQuery(
      input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}
    ) {
      persistedQuery {
        id
      }
    }
  }
}\`,
        operationName: \\"CreatePersistedQueryMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchFindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    authlifyToken(authlifyTokenId: $authlifyTokenId) {
      serviceMetadata {
        loggedInServices {
          usedTestFlow
          friendlyServiceName
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSetServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createServiceAuth(
      data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}
    ) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"SetServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateCLISessionEventMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createNetlifyCliTestEvent(
      input: {data: {payload: $payload}, sessionId: $sessionId}
    ) {
      event {
        id
        createdAt
        sessionId
      }
    }
  }
}\`,
        operationName: \\"CreateCLISessionEventMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionByIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSession(id: $id) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionByIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchDeprecated_FindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query Deprecated_FindLoggedInServicesQuery {
  me {
    serviceMetadata {
      loggedInServices {
        ...LoggedInServicesFragment
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"Deprecated_FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateEmptyPersonalTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersonalTokenWithNetlifySiteAnchor(
      input: {name: \\"Netlify AuthManager Token\\", netlifySiteId: $siteId}
    ) {
      accessToken {
        token
        name
        anchor
        netlifyId
      }
    }
  }
}\`,
        operationName: \\"CreateEmptyPersonalTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchServiceListQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph {
    services {
      friendlyServiceName
      logoUrl(style: $logoStyle)
      service
      slug
      supportsCustomRedirectUri
      supportsCustomServiceAuth
      supportsOauthLogin
    }
  }
}\`,
        operationName: \\"ServiceListQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAuthlifyTokenIdForPersonalToken = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {
  oneGraph {
    personalToken(accessToken: $personalToken) {
      netlifyId
    }
  }
}\`,
        operationName: \\"AuthlifyTokenIdForPersonalToken\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchPersistedQueryQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    persistedQuery(appId: $appId, id: $id) {
      id
      query
      allowedOperationNames
      description
      freeVariables
      fixedVariables
      tags
    }
  }
}\`,
        operationName: \\"PersistedQueryQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionsByAppIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSessionsByAppId(appId: $appId, first: 10) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionsByAppIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchListServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    services(filter: {supportsOauthLogin: true}) {
      friendlyServiceName
      service
      slug
      logoUrl(style: $logoStyle)
      availableScopes {
        category
        scope
        display
        isDefault
        isRequired
        description
        title
      }
    }
    app(id: $siteId) {
      serviceAuths {
        ...ServiceAuthFragment
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"ListServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeUpsertAppForSiteMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {
      org {
        id
        name
      }
      app {
        id
        name
        corsOrigins
        customCorsOrigins {
          friendlyServiceName
          displayName
          encodedValue
        }
      }
    }
  }
}\`,
        operationName: \\"UpsertAppForSiteMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    addCORSOriginToApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"AddCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeRemoveCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    removeCORSOriginFromApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"RemoveCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCORSOriginsQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $siteId) {
      ...AppCORSOriginFragment
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"CORSOriginsQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

const subscribeToTestSubscription = (
    variables,
    rawOptions
    ) => {
      const options = rawOptions || {};
      const netlifyGraphWebhookId = options.netlifyGraphWebhookId;
      const netlifyGraphWebhookUrl = options.webhookUrl || \`\${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=\${netlifyGraphWebhookId}\`;
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET
      const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}
  
      const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-9898-b051-db6027224112\\"\\"\\", doc: \\"\\"\\"A subscription with variables and a fragment to test code generation.\\"\\"\\") {
  poll(
    schedule: {every: {minutes: $minutes}}
    onlyTriggerWhenPayloadChanged: true
    webhookUrl: $netlifyGraphWebhookUrl
    secret: $netlifyGraphWebhookSecret
  ) {
    query {
      me {
        serviceMetadata {
          loggedInServices {
            ...LoggedInServicesFragment
          }
        }
      }
    }
  }
}\`;
  
      fetchNetlifyGraph({
        query: subscriptionOperationDoc,
        operationName: \\"TestSubscription\\",
        variables: fullVariables,
        options: options,
        fetchStrategy: \\"POST\\",
    })
  }
  
  const parseAndVerifyTestSubscriptionEvent = (event, options) => {
    if (!verifyRequestSignature({ event: event }, options)) {
      console.warn(\\"Unable to verify signature for TestSubscription\\")
      return null
    }
  
    return JSON.parse(event.body || '{}')
  }
  
  /**
   * The generated NetlifyGraph library with your operations
   */
  const functions = {
    /**
  * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
  */
  executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,
  /**
  * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
  */
  fetchAppSchemaQuery: fetchAppSchemaQuery,
  /**
  * Delete a OneGraph personal token for a user's site
  */
  executeDestroyTokenMutation : executeDestroyTokenMutation ,
  /**
  * Sign out of a service associated with a Authlify token
  */
  executeSignOutServicesMutation : executeSignOutServicesMutation ,
  /**
  * Update a service's (i.e. GitHub) enabled scope permissions
  */
  executeAddAuthsMutation : executeAddAuthsMutation ,
  /**
  * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
  */
  executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,
  /**
  * Delete a custom service auth
  */
  executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,
  /**
  * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
  */
  executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,
  /**
  * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
  */
  fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,
  /**
  * Create a custom service auth
  */
  executeSetServiceAuthMutation : executeSetServiceAuthMutation ,
  /**
  * Create a new session for the Netlify CLI to communicate with the React UI via events.
  */
  executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,
  /**
  * Get a Netlify CLI session by its id
  */
  fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,
  /**
  * (Deprecated) Find logged in services
  */
  fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,
  /**
  * Create a new OneGraph personal token for a user's site
  */
  executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,
  /**
  * Retrieve a list of _all_ supported services from OneGraph
  */
  fetchServiceListQuery: fetchServiceListQuery,
  /**
  * 
  */
  fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,
  /**
  * Retrieve a previously persisted operations doc
  */
  fetchPersistedQueryQuery: fetchPersistedQueryQuery,
  /**
  * List all the CLI sessions belonging to a site
  */
  fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,
  /**
  * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
  */
  fetchListServicesQuery: fetchListServicesQuery,
  /**
  * Ensure that an app resource exists on the OneGraph servers for a given site.
  */
  executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,
  /**
  * Add additional allowed CORS origins for calls to a site's Graph.
  */
  executeAddCORSOriginMutation : executeAddCORSOriginMutation ,
  /**
  * Remove the given CORS origins for calls to a site's Graph.
  */
  executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,
  /**
  * List the allowed CORS origins for calls to a site's Graph.
  */
  fetchCORSOriginsQuery: fetchCORSOriginsQuery,
  /**
  * A subscription with variables and a fragment to test code generation.
  */
  subscribeToTestSubscription:subscribeToTestSubscription,
  /**
   * Verify the event body is signed securely, and then parse the result.
   */
  parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent
  }
  
  export default functions"
`;

exports[`netlify graph function library runtime codegen library [netlify-builtin:serverless-0.0.1]:./dummy/index.d.ts} 1`] = `
"/* eslint-disable */
    // @ts-nocheck
    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
    
    export type NetlifyGraphFunctionOptions = {
      /**
       * The accessToken to use for the request
       */
      accessToken?: string;
      /**
       * The siteId to use for the request
       * @default process.env.SITE_ID
       */
      siteId?: string;
    }
    
    export type WebhookEvent = {
      body: string;
      headers: Record<string, string | null | undefined>;
    };
    
    export type GraphQLError = {
      \\"path\\": Array<string | number>;
      \\"message\\": string;
      \\"extensions\\": Record<string, unknown>;
    };
    
    /**
    * Subset of LoggedInServices
    */
    export type LoggedInServicesFragment = {
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  isLoggedIn: boolean;
  usedTestFlow: boolean;
  serviceInfo: {
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
};
  /**
  * The scopes that the user granted for this service. This is a best estimate of the scopes that were granted. Most services do not have a way to query the scopes on an auth, and some services do not return information about the scopes that were granted in the auth flow.
  */
grantedScopes?: Array<{
  /**
  * The name of the scope that the underlying service uses.
  */
scope: string;
}>;
  foreignUserId?: string;
};
    

/**
    * Basic info on a Service Auth
    */
    export type ServiceAuthFragment = {
  /**
  * id for the service auth
  */
id: string;
  /**
  * The service that the clientId and clientSecret belong to, e.g. \\"gmail\\"
  */
service: string;
  /**
  * clientId for the serviceAuth.
  */
clientId: string;
  /**
  * If true, the bearer token that is created fetchable by the user whose account the token grants access to.
  */
revealTokens: boolean;
  /**
  * Optional scopes to use for the OAuth flow.
  */
scopes?: Array<string>;
};
    

/**
    * Allowed CORS origins for calls to a site's Graph.
    */
    export type AppCORSOriginFragment = {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
  /**
  * Sites on Netlify associated with this app. OneGraph will allow CORS and authentication redirects to all previews, branch, and production deploys of these sites.
  */
netlifySiteNames: Array<string>;
};
    
    
    export type UpdateCLISessionMetadataMutationInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the session
 */
 \\"sessionId\\": string;  
 /**
 * Optional metadata for the session
 */
 \\"metadata\\": unknown
};
    
    export type UpdateCLISessionMetadataMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Update a CLI session.
  */
updateNetlifyCliSession: {
  /**
  * The session that was updated.
  */
session: {
  id: string;
  name?: string;
  metadata?: unknown;
  createdAt: string;
  lastEventAt?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
     */
    export function executeUpdateCLISessionMetadataMutation (
      variables: UpdateCLISessionMetadataMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpdateCLISessionMetadataMutation>;

export type AppSchemaQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"appId\\": string
};
    
    export type AppSchemaQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  appId: string;
  createdAt: string;
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
  updatedAt: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
     */
    export function fetchAppSchemaQuery(
      variables: AppSchemaQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AppSchemaQuery>;

export type DestroyTokenMutationInput = {
 \\"nfToken\\": string;  
 /**
 * Any OneGraph access token, refresh token, or JWT
 */
 \\"token\\"?: string;  
 /**
 * An Authlify Token identifier
 */
 \\"authlifyTokenId\\"?: string
};
    
    export type DestroyTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Revokes a OneGraph access token, refresh token, or JWT. After a token is destroyed, it can no longer be used to authenticate with OneGraph.

If you destroy a JWT, external services that rely on the claims embedded in the JWT may still accept the JWT and you will also have to revoke the JWT though the external service's revocation process.
  */
destroyToken: boolean;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a OneGraph personal token for a user's site
     */
    export function executeDestroyTokenMutation (
      variables: DestroyTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DestroyTokenMutation>;

export type SignOutServicesMutationInput = {
 \\"services\\": Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">;  
\\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type SignOutServicesMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  signoutServices: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Sign out of a service associated with a Authlify token
     */
    export function executeSignOutServicesMutation (
      variables: SignOutServicesMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SignOutServicesMutation>;

export type AddAuthsMutationInput = {
 \\"siteId\\": string;  
\\"authlifyTokenId\\"?: string;  
 /**
 * Token that will be destroyed and have its auths moved to the personal token.
 */
 \\"sToken\\": string;  
\\"nfToken\\": string
};
    
    export type AddAuthsMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addAuthsToPersonalToken: {
  /**
  * Personal access token that was updated by this mutation
  */
accessToken: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
  /**
  * Bearer token
  */
token: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Update a service's (i.e. GitHub) enabled scope permissions
     */
    export function executeAddAuthsMutation (
      variables: AddAuthsMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddAuthsMutation>;

export type CreateNewSchemaMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {/**
  * Whether to set this schema as the default for the app. Defaults to false.
  */
  \\"setAsDefaultForApp\\"?: boolean; /**
  * External GraphQL schemas to add
  */
  \\"externalGraphQLSchemas\\"?: Array<{/**
  * The id of the external GraphQL schema.
  */
  \\"externalGraphQLSchemaId\\": string}>; /**
  * Optional id of a Salesforce schema to attach to the app.
  */
  \\"salesforceSchemaId\\"?: string; /**
  * The optional id of the GraphQL schema that this was derived from.
  */
  \\"parentId\\"?: string; /**
  * The list of services that this schema should use. Leave blank if you want to add support for all supported services.
  */
  \\"enabledServices\\"?: Array<\\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\">; /**
  * The id of the app that the schema should belong to.
  */
  \\"appId\\": string}
};
    
    export type CreateNewSchemaMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createGraphQLSchema: {
  app: {
  /**
  * Customizations to the default GraphQL schema
  */
graphQLSchema?: {
  id: string;
};
};
  graphqlSchema: {
  id: string;
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
     */
    export function executeCreateNewSchemaMutation (
      variables: CreateNewSchemaMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateNewSchemaMutation>;

export type DeleteServiceAuthMutationInput = {
 \\"siteId\\": string;  
\\"serviceAuthId\\": string;  
\\"nfToken\\": string
};
    
    export type DeleteServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  destroyServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Delete a custom service auth
     */
    export function executeDeleteServiceAuthMutation (
      variables: DeleteServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<DeleteServiceAuthMutation>;

export type CreatePersistedQueryMutationInput = {
 \\"nfToken\\": string;  
\\"appId\\": string;  
\\"query\\": string;  
 /**
 * List of tags to add to the persisted query. Tags are free-form text that can be used to categorize persisted queries. Each tag must be under 256 characters and there can be a maximum of 10 tags on a single persisted query.
 */
 \\"tags\\": Array<string>;  
 /**
 * A description for the persisted query. Maximum length is 2096 characters.
 */
 \\"description\\": string;  
 /**
 * The parent persisted query. It can be used to track lineage of the query.
 */
 \\"parent\\"?: {/**
  * An optional list of tags to remove from the parent query. If any of the provided tags aren't present on the parent, the mutation will fail. No persisted queries will be created and no tags will be removed from the parent.
  */
  \\"removeTags\\"?: Array<string>; /**
  * The id of the parent
  */
  \\"id\\": string}
};
    
    export type CreatePersistedQueryMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createPersistedQuery: {
  persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
     */
    export function executeCreatePersistedQueryMutation (
      variables: CreatePersistedQueryMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreatePersistedQueryMutation>;

export type FindLoggedInServicesQueryInput = {
 \\"nfToken\\": string;  
\\"authlifyTokenId\\": string
};
    
    export type FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  authlifyToken: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment & {
  usedTestFlow: boolean;
  friendlyServiceName: string;
} >;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
     */
    export function fetchFindLoggedInServicesQuery(
      variables: FindLoggedInServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<FindLoggedInServicesQuery>;

export type SetServiceAuthMutationInput = {
 \\"service\\": \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\";  
\\"clientId\\": string;  
\\"clientSecret\\": string;  
\\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type SetServiceAuthMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createServiceAuth: {
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a custom service auth
     */
    export function executeSetServiceAuthMutation (
      variables: SetServiceAuthMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<SetServiceAuthMutation>;

export type CreateCLISessionEventMutationInput = {
 \\"nfToken\\": string;  
\\"sessionId\\": string;  
\\"payload\\": unknown
};
    
    export type CreateCLISessionEventMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  createNetlifyCliTestEvent: {
  event: {
  id: string;
  createdAt: string;
  sessionId: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new session for the Netlify CLI to communicate with the React UI via events.
     */
    export function executeCreateCLISessionEventMutation (
      variables: CreateCLISessionEventMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateCLISessionEventMutation>;

export type CliSessionByIdQueryInput = {
 \\"nfToken\\": string;  
\\"id\\": string
};
    
    export type CliSessionByIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Get a Netlify CLI session by its id.
  */
netlifyCliSession: {
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Get a Netlify CLI session by its id
     */
    export function fetchCliSessionByIdQuery(
      variables: CliSessionByIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionByIdQuery>;


    export type Deprecated_FindLoggedInServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array<LoggedInServicesFragment >;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * (Deprecated) Find logged in services
     */
    export function fetchDeprecated_FindLoggedInServicesQuery(
      /**
      * Pass \`{}\` as no variables are defined for this function.
      */
      variables: Record<string, never>,
      options?: NetlifyGraphFunctionOptions
    ): Promise<Deprecated_FindLoggedInServicesQuery>;

export type CreateEmptyPersonalTokenMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type CreateEmptyPersonalTokenMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Creates an empty personal token with a Netlify site anchor
  */
createPersonalTokenWithNetlifySiteAnchor: {
  /**
  * Personal access token that was created by this mutation
  */
accessToken: {
  /**
  * Bearer token
  */
token: string;
  /**
  * Token name, if it is a personal access token
  */
name?: string;
  /**
  * The anchor is like two-factor auth for the token. It ensures that the person who adds auth to the token is the same as the person who created the token.
  */
anchor?: \\"ONEGRAPH_USER\\" | \\"NETLIFY_USER\\" | \\"NETLIFY_SITE\\";
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Create a new OneGraph personal token for a user's site
     */
    export function executeCreateEmptyPersonalTokenMutation (
      variables: CreateEmptyPersonalTokenMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CreateEmptyPersonalTokenMutation>;

export type ServiceListQueryInput = {
 \\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ServiceListQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  supportsCustomRedirectUri: boolean;
  supportsCustomServiceAuth: boolean;
  supportsOauthLogin: boolean;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a list of _all_ supported services from OneGraph
     */
    export function fetchServiceListQuery(
      variables: ServiceListQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ServiceListQuery>;

export type AuthlifyTokenIdForPersonalTokenInput = {
 \\"personalToken\\": string
};
    
    export type AuthlifyTokenIdForPersonalToken = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Personal access token lookup
  */
personalToken?: {
  /**
  * Netlify-specific ID for the token
  */
netlifyId?: string;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * 
     */
    export function fetchAuthlifyTokenIdForPersonalToken(
      variables: AuthlifyTokenIdForPersonalTokenInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AuthlifyTokenIdForPersonalToken>;

export type PersistedQueryQueryInput = {
 \\"nfToken\\": string;  
 /**
 * The id of the app that the persisted query belongs to.
 */
 \\"appId\\": string;  
 /**
 * The id of the persisted query.
 */
 \\"id\\": string
};
    
    export type PersistedQueryQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Fetch a single persisted query by its id.
  */
persistedQuery: {
  /**
  * The persisted query's id.
  */
id: string;
  /**
  * The persisted query's query string.
  */
query: string;
  /**
  * The list of operation names that the caller of the query is allowed to execute. If the field is null, then all operationNames are allowed.
  */
allowedOperationNames?: Array<string>;
  /**
  * The user-defined description that was added to the query
  */
description?: string;
  /**
  * The list of variables that the caller of the query is allowed to provide.
  */
freeVariables?: Array<string>;
  /**
  * The default variables provided to the query.
  */
fixedVariables?: unknown;
  /**
  * The list of user-defined tags that were added to the query
  */
tags?: Array<string>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Retrieve a previously persisted operations doc
     */
    export function fetchPersistedQueryQuery(
      variables: PersistedQueryQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<PersistedQueryQuery>;

export type CliSessionsByAppIdQueryInput = {
 \\"nfToken\\": string;  
\\"appId\\": string
};
    
    export type CliSessionsByAppIdQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  /**
  * Netlify CLI sessions, orderd by createdAt descending.
  */
netlifyCliSessionsByAppId: Array<{
  id: string;
  name?: string;
  netlifyUserId: string;
  events: Array<{
  createdAt: string;
}>;
  createdAt: string;
  lastEventAt?: string;
  metadata?: unknown;
}>;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List all the CLI sessions belonging to a site
     */
    export function fetchCliSessionsByAppIdQuery(
      variables: CliSessionsByAppIdQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CliSessionsByAppIdQuery>;

export type ListServicesQueryInput = {
 \\"nfToken\\": string;  
 /**
 * App id
 */
 \\"siteId\\": string;  
\\"logoStyle\\"?: \\"DEFAULT\\" | \\"ROUNDED_RECTANGLE\\"
};
    
    export type ListServicesQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  services: Array<{
  friendlyServiceName: string;
  service: \\"ADROLL\\" | \\"ASANA\\" | \\"BOX\\" | \\"CONTENTFUL\\" | \\"DEV_TO\\" | \\"DOCUSIGN\\" | \\"DRIBBBLE\\" | \\"DROPBOX\\" | \\"EGGHEADIO\\" | \\"EVENTIL\\" | \\"FACEBOOK\\" | \\"FIREBASE\\" | \\"GITHUB\\" | \\"GMAIL\\" | \\"GONG\\" | \\"GOOGLE\\" | \\"GOOGLE_ADS\\" | \\"GOOGLE_ANALYTICS\\" | \\"GOOGLE_CALENDAR\\" | \\"GOOGLE_COMPUTE\\" | \\"GOOGLE_DOCS\\" | \\"GOOGLE_SEARCH_CONSOLE\\" | \\"GOOGLE_TRANSLATE\\" | \\"HUBSPOT\\" | \\"INTERCOM\\" | \\"MAILCHIMP\\" | \\"MEETUP\\" | \\"NETLIFY\\" | \\"NOTION\\" | \\"OUTREACH\\" | \\"PRODUCT_HUNT\\" | \\"QUICKBOOKS\\" | \\"SALESFORCE\\" | \\"SANITY\\" | \\"SLACK\\" | \\"SPOTIFY\\" | \\"STRIPE\\" | \\"TRELLO\\" | \\"TWILIO\\" | \\"TWITTER\\" | \\"TWITCH_TV\\" | \\"YNAB\\" | \\"YOUTUBE\\" | \\"ZEIT\\" | \\"ZENDESK\\" | \\"AIRTABLE\\" | \\"APOLLO\\" | \\"BREX\\" | \\"BUNDLEPHOBIA\\" | \\"CHARGEBEE\\" | \\"CLEARBIT\\" | \\"CLOUDFLARE\\" | \\"CRUNCHBASE\\" | \\"DESCURI\\" | \\"FEDEX\\" | \\"GOOGLE_MAPS\\" | \\"GRAPHCMS\\" | \\"IMMIGRATION_GRAPH\\" | \\"LOGDNA\\" | \\"MIXPANEL\\" | \\"MUX\\" | \\"NPM\\" | \\"ONEGRAPH\\" | \\"ORBIT\\" | \\"OPEN_COLLECTIVE\\" | \\"RSS\\" | \\"UPS\\" | \\"USPS\\" | \\"WORDPRESS\\";
  /**
  * Service string that can be provided in the URL when going through the oauth flow.
  */
slug: string;
  /**
  * A short-lived svg image url of the logo for the service. May be null.
  */
logoUrl?: string;
  availableScopes?: Array<{
  category?: string;
  scope: string;
  display: string;
  isDefault: boolean;
  isRequired: boolean;
  description: string;
  title?: string;
}>;
}>;
  app: {
  /**
  * The custom clientId/clientSecret that have been set for services (e.g. Gmail and Slack) that belong to this OneGraph app
  */
serviceAuths: Array<ServiceAuthFragment>;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
     */
    export function fetchListServicesQuery(
      variables: ListServicesQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<ListServicesQuery>;

export type UpsertAppForSiteMutationInput = {
 \\"nfToken\\": string;  
\\"siteId\\": string
};
    
    export type UpsertAppForSiteMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  upsertAppForNetlifySite: {
  /**
  * The app that is associated with the Netlify account.
  */
org: {
  /**
  * The id of the OneGraph Org
  */
id: string;
  /**
  * The name of the OneGraph Org
  */
name: string;
};
  /**
  * The app that is associated with the Netlify site.
  */
app: {
  /**
  * The id of the OneGraph App
  */
id: string;
  /**
  * The name of the OneGraph App
  */
name: string;
  /**
  * The origins allowed for this OneGraph App from CORS requests
  */
corsOrigins: Array<string>;
  /**
  * Custom cors origins
  */
customCorsOrigins: Array<{
  /**
  * The friendly service name for the cors origin
  */
friendlyServiceName: string;
  /**
  * The name of the origin that should be displayed, e.g. oneblog for oneblog.netlify.app.
  */
displayName: string;
  /**
  * The encoded value as a string, used to remove the custom cors origin.
  */
encodedValue: string;
}>;
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Ensure that an app resource exists on the OneGraph servers for a given site.
     */
    export function executeUpsertAppForSiteMutation (
      variables: UpsertAppForSiteMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<UpsertAppForSiteMutation>;

export type AddCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type AddCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  addCORSOriginToApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Add additional allowed CORS origins for calls to a site's Graph.
     */
    export function executeAddCORSOriginMutation (
      variables: AddCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<AddCORSOriginMutation>;

export type RemoveCORSOriginMutationInput = {
 \\"nfToken\\": string;  
\\"input\\": {\\"corsOrigin\\": string; \\"appId\\": string}
};
    
    export type RemoveCORSOriginMutation = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  removeCORSOriginFromApp: {
  app: AppCORSOriginFragment ;
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * Remove the given CORS origins for calls to a site's Graph.
     */
    export function executeRemoveCORSOriginMutation (
      variables: RemoveCORSOriginMutationInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<RemoveCORSOriginMutation>;

export type CORSOriginsQueryInput = {
  /**
 * App id
 */
 \\"siteId\\": string;  
\\"nfToken\\": string
};
    
    export type CORSOriginsQuery = {
  /**
  * Any data from the function will be returned here
  */
data: {
  oneGraph: {
  app: AppCORSOriginFragment ;
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
};
    
    /**
     * List the allowed CORS origins for calls to a site's Graph.
     */
    export function fetchCORSOriginsQuery(
      variables: CORSOriginsQueryInput,
      options?: NetlifyGraphFunctionOptions
    ): Promise<CORSOriginsQuery>;

/**
  * A subscription with variables and a fragment to test code generation.
  */
  export function subscribeToTestSubscription(
    /**
     * This will be available in your webhook handler as a query parameter.
     * Use this to keep track of which subscription you're receiving
     * events for.
     */
    variables: {
  /**
 * How many minutes to wait before re-running the underlying query
 */
 \\"minutes\\"?: number
},
    options?: {
      /**
       * The accessToken to use for the lifetime of the subscription.
       */
      accessToken?: string | null | undefined;
      /**
       * A string id that will be passed to your webhook handler as a query parameter
       * along with each event.
       * This can be used to keep track of which subscription you're receiving
       */
      netlifyGraphWebhookId?: string | null | undefined;
      /**
       * The absolute URL of your webhook handler to handle events from this subscription.
       */
      webhookUrl?: string | null | undefined;
      /**
       * The secret to use when signing the webhook request. Use this to verify
       * that the webhook payload is coming from Netlify Graph. Defaults to the
       * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.
       */
      webhookSecret?: string | null | undefined;
    }) : void
  
  export type TestSubscriptionEvent = {
  /**
  * Any data from the function will be returned here
  */
data: {
  poll: {
  query: {
  me: {
  /**
  * Metadata and logged-in state for all OneGraph services
  */
serviceMetadata: {
  loggedInServices: Array</** No fields, named fragments, or inline fragments found */ Record<string, unknown>>;
};
};
};
};
};
  /**
  * Any errors from the function will be returned here
  */
errors?: Array<GraphQLError>;
}
  
  /**
   * Verify the TestSubscription event body is signed securely, and then parse the result.
   */
  export function parseAndVerifyTestSubscriptionEvent (/** A Netlify Handler Event */ event : WebhookEvent) : null | TestSubscriptionEvent
  
    
    export interface Functions {
      /**
    * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
    */
    executeUpdateCLISessionMetadataMutation : typeof executeUpdateCLISessionMetadataMutation ,
  /**
    * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
    */
    fetchAppSchemaQuery: typeof fetchAppSchemaQuery,
  /**
    * Delete a OneGraph personal token for a user's site
    */
    executeDestroyTokenMutation : typeof executeDestroyTokenMutation ,
  /**
    * Sign out of a service associated with a Authlify token
    */
    executeSignOutServicesMutation : typeof executeSignOutServicesMutation ,
  /**
    * Update a service's (i.e. GitHub) enabled scope permissions
    */
    executeAddAuthsMutation : typeof executeAddAuthsMutation ,
  /**
    * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
    */
    executeCreateNewSchemaMutation : typeof executeCreateNewSchemaMutation ,
  /**
    * Delete a custom service auth
    */
    executeDeleteServiceAuthMutation : typeof executeDeleteServiceAuthMutation ,
  /**
    * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
    */
    executeCreatePersistedQueryMutation : typeof executeCreatePersistedQueryMutation ,
  /**
    * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
    */
    fetchFindLoggedInServicesQuery: typeof fetchFindLoggedInServicesQuery,
  /**
    * Create a custom service auth
    */
    executeSetServiceAuthMutation : typeof executeSetServiceAuthMutation ,
  /**
    * Create a new session for the Netlify CLI to communicate with the React UI via events.
    */
    executeCreateCLISessionEventMutation : typeof executeCreateCLISessionEventMutation ,
  /**
    * Get a Netlify CLI session by its id
    */
    fetchCliSessionByIdQuery: typeof fetchCliSessionByIdQuery,
  /**
    * (Deprecated) Find logged in services
    */
    fetchDeprecated_FindLoggedInServicesQuery: typeof fetchDeprecated_FindLoggedInServicesQuery,
  /**
    * Create a new OneGraph personal token for a user's site
    */
    executeCreateEmptyPersonalTokenMutation : typeof executeCreateEmptyPersonalTokenMutation ,
  /**
    * Retrieve a list of _all_ supported services from OneGraph
    */
    fetchServiceListQuery: typeof fetchServiceListQuery,
  /**
    * 
    */
    fetchAuthlifyTokenIdForPersonalToken: typeof fetchAuthlifyTokenIdForPersonalToken,
  /**
    * Retrieve a previously persisted operations doc
    */
    fetchPersistedQueryQuery: typeof fetchPersistedQueryQuery,
  /**
    * List all the CLI sessions belonging to a site
    */
    fetchCliSessionsByAppIdQuery: typeof fetchCliSessionsByAppIdQuery,
  /**
    * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
    */
    fetchListServicesQuery: typeof fetchListServicesQuery,
  /**
    * Ensure that an app resource exists on the OneGraph servers for a given site.
    */
    executeUpsertAppForSiteMutation : typeof executeUpsertAppForSiteMutation ,
  /**
    * Add additional allowed CORS origins for calls to a site's Graph.
    */
    executeAddCORSOriginMutation : typeof executeAddCORSOriginMutation ,
  /**
    * Remove the given CORS origins for calls to a site's Graph.
    */
    executeRemoveCORSOriginMutation : typeof executeRemoveCORSOriginMutation ,
  /**
    * List the allowed CORS origins for calls to a site's Graph.
    */
    fetchCORSOriginsQuery: typeof fetchCORSOriginsQuery,
  /**
    * A subscription with variables and a fragment to test code generation.
    */
    subscribeToTestSubscription:subscribeToTestSubscription,
    /**
     * Verify the event body is signed securely, and then parse the result.
     */
    parseAndVerifyTestSubscriptionEvent: typeof parseAndVerifyTestSubscriptionEvent
    }
    
    export const functions: Functions;
    
    export default functions;
    "
`;

exports[`netlify graph function library runtime codegen library [netlify-builtin:serverless-0.0.1]:./dummy/index.js} 1`] = `
"/* eslint-disable */
  // @ts-nocheck
  // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
  
  // Basic LRU cache implementation
  const makeLRUCache = (max) => {
    return { max: max, cache: new Map() };
  };
  
  const oldestCacheKey = (lru) => {
    return lru.keys().next().value
  }
  
  // Depend on Map keeping track of insertion order
  const getFromCache = (lru, key) => {
    const item = lru.cache.get(key);
    if (item) {
      // Delete key and re-insert so key is now at the end,
      // and now the last to be gc'd.
      lru.cache.delete(key);
      lru.cache.set(key, item);
    }
    return item;
  };
  
  const setInCache = (lru, key, value) => {
    if (lru.cache.has(key)) {
      lru.cache.delete(key);
    }
    if (lru.cache.size == lru.max) {
      const cacheKey = oldestCacheKey(lru);
  
      if (cacheKey) {
        lru.cache.delete(cacheKey);
      }
    }
  
    lru.cache.set(key, value);
  };
  
  // Cache the results of the Netlify Graph API for conditional requests
  const cache = makeLRUCache(100);
  
  const calculateCacheKey = (payload) => {
    return JSON.stringify(payload);
  };

  const schemaId = 'stable-schema-id';

  const netlifyGraphHostWithProtocol =
    process.env.NETLIFY_GRAPH_HOST_WITH_PROTOCOL || 'https://graph.netlify.com';

  const makeNetlifyGraphUrl = ({ operationName, siteId }) => {
    return (
      netlifyGraphHostWithProtocol +
      '/graphql?app_id=' +
      siteId +
      '&operationName=' +
      operationName +
      '&schema_id=' +
      schemaId
    );
  };

  const httpFetch = (operationName, options) => {
    const reqBody = options.body || null;
    const userHeaders = options.headers || {};
    const headers = {
      ...userHeaders,
      'Content-Type': 'application/json',
    };

    const timeoutMs = 30_000;

    const reqOptions = {
      method: 'POST',
      headers: headers,
      timeout: timeoutMs,
      body: reqBody,
    };

    const siteId = options.siteId || process.env.SITE_ID;
    const netlifyGraphUrl = makeNetlifyGraphUrl({ operationName: operationName, siteId: siteId });

    return fetch(netlifyGraphUrl, reqOptions).then((body) => {
      return body.text().then((bodyString) => {
        const headers = {};
        body.headers.forEach((k, v) => (headers[k] = v));
  
        return {
          body: bodyString,
          headers: headers,
          status: body.status,
        };
      });
    });
  };
 
  const fetchNetlifyGraph = function fetchNetlifyGraph(input) {
    const query = input.query;
    const docId = input.doc_id;
    const operationName = input.operationName;
    const variables = input.variables;
  
    const options = input.options || {};
    const accessToken = options.accessToken;
  
    const payload = {
      query: query,
      doc_id: docId,
      variables: variables,
      operationName: operationName,
    };
  
    let cachedOrLiveValue = new Promise((resolve) => {
      const cacheKey = calculateCacheKey(payload);
  
      // Check the cache for a previous result
      const cachedResultPair = getFromCache(cache, cacheKey);
  
      let conditionalHeaders = {
        'If-None-Match': '',
      };
      let cachedResultValue;
  
      if (cachedResultPair) {
        const [etag, previousResult] = cachedResultPair;
        conditionalHeaders = {
          'If-None-Match': etag,
        };
        cachedResultValue = previousResult;
      }
  
      const response = httpFetch(operationName, {
        ...options,
        method: 'POST',
        headers: {
          ...conditionalHeaders,
          Authorization: accessToken ? 'Bearer ' + accessToken : '',
        },
        body: JSON.stringify(payload),
      });
  
      response.then((result) => {
        // Check response headers for a 304 Not Modified
        if (result.status === 304) {
          // Return the cached result
          resolve(cachedResultValue);
        } else if (result.status === 200) {
          // Update the cache with the new etag and result
          const etag = result.headers['etag'];
          const resultJson = JSON.parse(result.body);
          if (etag) {
            // Make a note of the new etag for the given payload
            setInCache(cache, cacheKey, [etag, resultJson]);
          }
          resolve(resultJson);
        } else {
          return result.json().then((json) => {
            resolve(json);
          });
        }
      });
    });
  
    return cachedOrLiveValue;
  };

  export const executeUpdateCLISessionMetadataMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpdateCLISessionMetadataMutation($nfToken: String!, $sessionId: String!, $metadata: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {
      session {
        id
        name
        metadata
        createdAt
        lastEventAt
      }
    }
  }
}\`,
        operationName: \\"UpdateCLISessionMetadataMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAppSchemaQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AppSchemaQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $appId) {
      graphQLSchema {
        appId
        createdAt
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
        updatedAt
      }
    }
  }
}\`,
        operationName: \\"AppSchemaQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDestroyTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DestroyTokenMutation($nfToken: String!, $token: String, $authlifyTokenId: String) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyToken(token: $token, authlifyTokenId: $authlifyTokenId)
  }
}\`,
        operationName: \\"DestroyTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSignOutServicesMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SignOutServicesMutation($services: [OneGraphServiceEnum!]!, $nfToken: String!, $authlifyTokenId: String!) {
  signoutServices(
    data: {services: $services, anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, authlifyTokenId: $authlifyTokenId}
  ) {
    me {
      serviceMetadata {
        loggedInServices {
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"SignOutServicesMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddAuthsMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddAuthsMutation($siteId: String!, $authlifyTokenId: String, $sToken: String!, $nfToken: String!) {
  oneGraph {
    addAuthsToPersonalToken(
      input: {anchorAuth: {netlifyAuth: {oauthToken: $nfToken}}, sacrificialToken: $sToken, authlifyTokenId: $authlifyTokenId, appId: $siteId}
    ) {
      accessToken {
        netlifyId
        token
      }
    }
  }
}\`,
        operationName: \\"AddAuthsMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateNewSchemaMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateNewSchemaMutation($nfToken: String!, $input: OneGraphCreateGraphQLSchemaInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createGraphQLSchema(input: $input) {
      app {
        graphQLSchema {
          id
        }
      }
      graphqlSchema {
        id
        services {
          friendlyServiceName
          logoUrl
          service
          slug
          supportsCustomRedirectUri
          supportsCustomServiceAuth
          supportsOauthLogin
        }
      }
    }
  }
}\`,
        operationName: \\"CreateNewSchemaMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeDeleteServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation DeleteServiceAuthMutation($siteId: String!, $serviceAuthId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    destroyServiceAuth(data: {appId: $siteId, serviceAuthId: $serviceAuthId}) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"DeleteServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreatePersistedQueryMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreatePersistedQueryMutation($nfToken: String!, $appId: String!, $query: String!, $tags: [String!]!, $description: String!, $parent: OneGraphCreatePersistedQueryParentInput) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersistedQuery(
      input: {query: $query, appId: $appId, tags: $tags, description: $description, parent: $parent}
    ) {
      persistedQuery {
        id
      }
    }
  }
}\`,
        operationName: \\"CreatePersistedQueryMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchFindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query FindLoggedInServicesQuery($nfToken: String!, $authlifyTokenId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    authlifyToken(authlifyTokenId: $authlifyTokenId) {
      serviceMetadata {
        loggedInServices {
          usedTestFlow
          friendlyServiceName
          ...LoggedInServicesFragment
        }
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeSetServiceAuthMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation SetServiceAuthMutation($service: OneGraphCustomServiceAuthServiceEnum!, $clientId: String!, $clientSecret: String!, $siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createServiceAuth(
      data: {service: $service, clientId: $clientId, clientSecret: $clientSecret, appId: $siteId, revealTokens: true}
    ) {
      app {
        serviceAuths {
          ...ServiceAuthFragment
        }
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"SetServiceAuthMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateCLISessionEventMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateCLISessionEventMutation($nfToken: String!, $sessionId: String!, $payload: JSON!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createNetlifyCliTestEvent(
      input: {data: {payload: $payload}, sessionId: $sessionId}
    ) {
      event {
        id
        createdAt
        sessionId
      }
    }
  }
}\`,
        operationName: \\"CreateCLISessionEventMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionByIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionByIdQuery($nfToken: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSession(id: $id) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionByIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchDeprecated_FindLoggedInServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query Deprecated_FindLoggedInServicesQuery {
  me {
    serviceMetadata {
      loggedInServices {
        ...LoggedInServicesFragment
      }
    }
  }
}

fragment LoggedInServicesFragment on OneGraphServiceMetadata @netlify(id: \\"\\"\\"12b5bdea-9bab-4124-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Subset of LoggedInServices\\"\\"\\") {
  friendlyServiceName
  service
  isLoggedIn
  usedTestFlow
  serviceInfo {
    logoUrl
    availableScopes {
      category
      scope
      display
      isDefault
      isRequired
      description
      title
    }
  }
  grantedScopes {
    scope
  }
  foreignUserId
}\`,
        operationName: \\"Deprecated_FindLoggedInServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeCreateEmptyPersonalTokenMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation CreateEmptyPersonalTokenMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    createPersonalTokenWithNetlifySiteAnchor(
      input: {name: \\"Netlify AuthManager Token\\", netlifySiteId: $siteId}
    ) {
      accessToken {
        token
        name
        anchor
        netlifyId
      }
    }
  }
}\`,
        operationName: \\"CreateEmptyPersonalTokenMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchServiceListQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ServiceListQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph {
    services {
      friendlyServiceName
      logoUrl(style: $logoStyle)
      service
      slug
      supportsCustomRedirectUri
      supportsCustomServiceAuth
      supportsOauthLogin
    }
  }
}\`,
        operationName: \\"ServiceListQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchAuthlifyTokenIdForPersonalToken = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query AuthlifyTokenIdForPersonalToken($personalToken: String!) {
  oneGraph {
    personalToken(accessToken: $personalToken) {
      netlifyId
    }
  }
}\`,
        operationName: \\"AuthlifyTokenIdForPersonalToken\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchPersistedQueryQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query PersistedQueryQuery($nfToken: String!, $appId: String!, $id: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    persistedQuery(appId: $appId, id: $id) {
      id
      query
      allowedOperationNames
      description
      freeVariables
      fixedVariables
      tags
    }
  }
}\`,
        operationName: \\"PersistedQueryQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCliSessionsByAppIdQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CliSessionsByAppIdQuery($nfToken: String!, $appId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    netlifyCliSessionsByAppId(appId: $appId, first: 10) {
      id
      name
      netlifyUserId
      events {
        createdAt
      }
      createdAt
      lastEventAt
      metadata
    }
  }
}\`,
        operationName: \\"CliSessionsByAppIdQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchListServicesQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query ListServicesQuery($nfToken: String!, $siteId: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    services(filter: {supportsOauthLogin: true}) {
      friendlyServiceName
      service
      slug
      logoUrl(style: $logoStyle)
      availableScopes {
        category
        scope
        display
        isDefault
        isRequired
        description
        title
      }
    }
    app(id: $siteId) {
      serviceAuths {
        ...ServiceAuthFragment
      }
    }
  }
}

fragment ServiceAuthFragment on OneGraphServiceAuth @netlify(id: \\"\\"\\"12b5bdea-9bab-4164-a731-5e697b1553be\\"\\"\\", doc: \\"\\"\\"Basic info on a Service Auth\\"\\"\\") {
  id
  service
  clientId
  revealTokens
  scopes
}\`,
        operationName: \\"ListServicesQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeUpsertAppForSiteMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation UpsertAppForSiteMutation($nfToken: String!, $siteId: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {
      org {
        id
        name
      }
      app {
        id
        name
        corsOrigins
        customCorsOrigins {
          friendlyServiceName
          displayName
          encodedValue
        }
      }
    }
  }
}\`,
        operationName: \\"UpsertAppForSiteMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeAddCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation AddCORSOriginMutation($nfToken: String!, $input: OneGraphAddCORSOriginToAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    addCORSOriginToApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"AddCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const executeRemoveCORSOriginMutation  = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`mutation RemoveCORSOriginMutation($nfToken: String!, $input: OneGraphRemoveCORSOriginFromAppInput!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    removeCORSOriginFromApp(input: $input) {
      app {
        ...AppCORSOriginFragment
      }
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"RemoveCORSOriginMutation\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

export const fetchCORSOriginsQuery = (
      variables,
      options
    ) => {
      return fetchNetlifyGraph({
        query: \`query CORSOriginsQuery($siteId: String!, $nfToken: String!) {
  oneGraph(auths: {netlifyAuth: {oauthToken: $nfToken}}) {
    app(id: $siteId) {
      ...AppCORSOriginFragment
    }
  }
}

fragment AppCORSOriginFragment on OneGraphApp @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-48d8-b051-db6027224145\\"\\"\\", doc: \\"\\"\\"Allowed CORS origins for calls to a site's Graph.\\"\\"\\") {
  id
  corsOrigins
  customCorsOrigins {
    friendlyServiceName
    displayName
    encodedValue
  }
  netlifySiteNames
}\`,
        operationName: \\"CORSOriginsQuery\\",
        variables: variables,
        options: options,
        fetchStrategy: \\"POST\\",
      });
    }
  

const subscribeToTestSubscription = (
    variables,
    rawOptions
    ) => {
      const options = rawOptions || {};
      const netlifyGraphWebhookId = options.netlifyGraphWebhookId;
      const netlifyGraphWebhookUrl = options.webhookUrl || \`\${process.env.DEPLOY_URL}/webhooks/TestSubscription?netlifyGraphWebhookId=\${netlifyGraphWebhookId}\`;
      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET
      const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}
  
      const subscriptionOperationDoc = \`subscription TestSubscription($minutes: Int = 1, $netlifyGraphWebhookUrl: String!, $netlifyGraphWebhookSecret: OneGraphSubscriptionSecretInput!) @netlify(id: \\"\\"\\"e3d4bb8b-2fb5-9898-b051-db6027224112\\"\\"\\", doc: \\"\\"\\"A subscription with variables and a fragment to test code generation.\\"\\"\\") {
  poll(
    schedule: {every: {minutes: $minutes}}
    onlyTriggerWhenPayloadChanged: true
    webhookUrl: $netlifyGraphWebhookUrl
    secret: $netlifyGraphWebhookSecret
  ) {
    query {
      me {
        serviceMetadata {
          loggedInServices {
            ...LoggedInServicesFragment
          }
        }
      }
    }
  }
}\`;
  
      fetchNetlifyGraph({
        query: subscriptionOperationDoc,
        operationName: \\"TestSubscription\\",
        variables: fullVariables,
        options: options,
        fetchStrategy: \\"POST\\",
    })
  }
  
  const parseAndVerifyTestSubscriptionEvent = (event, options) => {
    if (!verifyRequestSignature({ event: event }, options)) {
      console.warn(\\"Unable to verify signature for TestSubscription\\")
      return null
    }
  
    return JSON.parse(event.body || '{}')
  }
  
  /**
   * The generated NetlifyGraph library with your operations
   */
  const functions = {
    /**
  * Modify the metadata of an existing CLI session (an intentionally untype bag of \`JSON\`).
  */
  executeUpdateCLISessionMetadataMutation : executeUpdateCLISessionMetadataMutation ,
  /**
  * Get the _metadata_ about a site's current GraphQL schema:
* 
* - enabled services
* - schema id
* - creation date
* 
* etc.
  */
  fetchAppSchemaQuery: fetchAppSchemaQuery,
  /**
  * Delete a OneGraph personal token for a user's site
  */
  executeDestroyTokenMutation : executeDestroyTokenMutation ,
  /**
  * Sign out of a service associated with a Authlify token
  */
  executeSignOutServicesMutation : executeSignOutServicesMutation ,
  /**
  * Update a service's (i.e. GitHub) enabled scope permissions
  */
  executeAddAuthsMutation : executeAddAuthsMutation ,
  /**
  * Create a new GraphQL schema for an app with a set of services enabled. Note that this just makes the schema _available_ for the app to use, it doesn't set it as the default for all queries to use.
  */
  executeCreateNewSchemaMutation : executeCreateNewSchemaMutation ,
  /**
  * Delete a custom service auth
  */
  executeDeleteServiceAuthMutation : executeDeleteServiceAuthMutation ,
  /**
  * Given a document with GraphQL operations, persist them to OneGraph (with not specific metadata, e.g. cache TTL or auth) for later retrieval _or_ execution.
  */
  executeCreatePersistedQueryMutation : executeCreatePersistedQueryMutation ,
  /**
  * Fetch all logged-in OneGraph services (GitHub, Spotify, etc.) for a user's site
  */
  fetchFindLoggedInServicesQuery: fetchFindLoggedInServicesQuery,
  /**
  * Create a custom service auth
  */
  executeSetServiceAuthMutation : executeSetServiceAuthMutation ,
  /**
  * Create a new session for the Netlify CLI to communicate with the React UI via events.
  */
  executeCreateCLISessionEventMutation : executeCreateCLISessionEventMutation ,
  /**
  * Get a Netlify CLI session by its id
  */
  fetchCliSessionByIdQuery: fetchCliSessionByIdQuery,
  /**
  * (Deprecated) Find logged in services
  */
  fetchDeprecated_FindLoggedInServicesQuery: fetchDeprecated_FindLoggedInServicesQuery,
  /**
  * Create a new OneGraph personal token for a user's site
  */
  executeCreateEmptyPersonalTokenMutation : executeCreateEmptyPersonalTokenMutation ,
  /**
  * Retrieve a list of _all_ supported services from OneGraph
  */
  fetchServiceListQuery: fetchServiceListQuery,
  /**
  * 
  */
  fetchAuthlifyTokenIdForPersonalToken: fetchAuthlifyTokenIdForPersonalToken,
  /**
  * Retrieve a previously persisted operations doc
  */
  fetchPersistedQueryQuery: fetchPersistedQueryQuery,
  /**
  * List all the CLI sessions belonging to a site
  */
  fetchCliSessionsByAppIdQuery: fetchCliSessionsByAppIdQuery,
  /**
  * Fetch all available OneGraph services (GitHub, Spotify, etc.), as well as any custom service auths that may be installed for a site.
  */
  fetchListServicesQuery: fetchListServicesQuery,
  /**
  * Ensure that an app resource exists on the OneGraph servers for a given site.
  */
  executeUpsertAppForSiteMutation : executeUpsertAppForSiteMutation ,
  /**
  * Add additional allowed CORS origins for calls to a site's Graph.
  */
  executeAddCORSOriginMutation : executeAddCORSOriginMutation ,
  /**
  * Remove the given CORS origins for calls to a site's Graph.
  */
  executeRemoveCORSOriginMutation : executeRemoveCORSOriginMutation ,
  /**
  * List the allowed CORS origins for calls to a site's Graph.
  */
  fetchCORSOriginsQuery: fetchCORSOriginsQuery,
  /**
  * A subscription with variables and a fragment to test code generation.
  */
  subscribeToTestSubscription:subscribeToTestSubscription,
  /**
   * Verify the event body is signed securely, and then parse the result.
   */
  parseAndVerifyTestSubscriptionEvent: parseAndVerifyTestSubscriptionEvent
  }
  
  export default functions"
`;
